{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MonitorInterval = exports.RTTPinger = exports.Monitor = void 0;\nconst timers_1 = require(\"timers\");\nconst bson_1 = require(\"../bson\");\nconst connect_1 = require(\"../cmap/connect\");\nconst connection_1 = require(\"../cmap/connection\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nconst events_1 = require(\"./events\");\nconst server_1 = require(\"./server\");\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\nconst kConnection = Symbol('connection');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nconst kRTTPinger = Symbol('rttPinger');\n/** @internal */\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = (0, utils_1.makeStateMachine)({\n  [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],\n  [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor) {\n  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @internal */\nclass Monitor extends mongo_types_1.TypedEventEmitter {\n  get connection() {\n    return this[kConnection];\n  }\n  constructor(server, options) {\n    super();\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new mongo_types_1.CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: common_1.STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: options.connectTimeoutMS ?? 10000,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500\n    });\n    const cancellationToken = this[kCancellationToken];\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = Object.assign({\n      id: '<monitor>',\n      generation: server.pool.generation,\n      connectionType: connection_1.Connection,\n      cancellationToken,\n      hostAddress: server.description.hostAddress\n    }, options,\n    // force BSON serialization options\n    {\n      raw: false,\n      useBigInt64: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    });\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n  connect() {\n    if (this.s.state !== common_1.STATE_CLOSED) {\n      return;\n    }\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n    this[kMonitorId]?.wake();\n  }\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this);\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\n    });\n  }\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this);\n    // close monitor\n    this.emit('close');\n    stateTransition(this, common_1.STATE_CLOSED);\n  }\n}\nexports.Monitor = Monitor;\nfunction resetMonitorState(monitor) {\n  monitor[kMonitorId]?.stop();\n  monitor[kMonitorId] = undefined;\n  monitor[kRTTPinger]?.close();\n  monitor[kRTTPinger] = undefined;\n  monitor[kCancellationToken].emit('cancel');\n  monitor[kConnection]?.destroy({\n    force: true\n  });\n  monitor[kConnection] = undefined;\n}\nfunction checkServer(monitor, callback) {\n  let start = (0, utils_1.now)();\n  monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n  function failureHandler(err) {\n    monitor[kConnection]?.destroy({\n      force: true\n    });\n    monitor[kConnection] = undefined;\n    monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));\n    const error = !(err instanceof error_1.MongoError) ? new error_1.MongoError(err) : err;\n    error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);\n    if (error instanceof error_1.MongoNetworkTimeoutError) {\n      error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);\n    }\n    monitor.emit('resetServer', error);\n    callback(err);\n  }\n  const connection = monitor[kConnection];\n  if (connection && !connection.closed) {\n    const {\n      serverApi,\n      helloOk\n    } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n    const cmd = {\n      [serverApi?.version || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,\n      ...(isAwaitable && topologyVersion ? {\n        maxAwaitTimeMS,\n        topologyVersion: makeTopologyVersion(topologyVersion)\n      } : {})\n    };\n    const options = isAwaitable ? {\n      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n      exhaustAllowed: true\n    } : {\n      socketTimeoutMS: connectTimeoutMS\n    };\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({\n        heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS\n      }, monitor.connectOptions));\n    }\n    connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options, (err, hello) => {\n      if (err) {\n        return failureHandler(err);\n      }\n      if (!('isWritablePrimary' in hello)) {\n        // Provide hello-style response document.\n        hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];\n      }\n      const rttPinger = monitor[kRTTPinger];\n      const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello));\n      // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      if (isAwaitable && hello.topologyVersion) {\n        monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n        start = (0, utils_1.now)();\n      } else {\n        monitor[kRTTPinger]?.close();\n        monitor[kRTTPinger] = undefined;\n        callback(undefined, hello);\n      }\n    });\n    return;\n  }\n  // connecting does an implicit `hello`\n  (0, connect_1.connect)(monitor.connectOptions, (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n      failureHandler(err);\n      return;\n    }\n    if (conn) {\n      // Tell the connection that we are using the streaming protocol so that the\n      // connection's message stream will only read the last hello on the buffer.\n      conn.isMonitoringConnection = true;\n      if (isInCloseState(monitor)) {\n        conn.destroy({\n          force: true\n        });\n        return;\n      }\n      monitor[kConnection] = conn;\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));\n      callback(undefined, conn.hello);\n    }\n  });\n}\nfunction monitorServer(monitor) {\n  return callback => {\n    if (monitor.s.state === STATE_MONITORING) {\n      process.nextTick(callback);\n      return;\n    }\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n      callback();\n    }\n    checkServer(monitor, (err, hello) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {\n          return done();\n        }\n      }\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (hello && hello.topologyVersion) {\n        (0, timers_1.setTimeout)(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId]?.wake();\n          }\n        }, 0);\n      }\n      done();\n    });\n  };\n}\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n  };\n}\n/** @internal */\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = undefined;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n  close() {\n    this.closed = true;\n    (0, timers_1.clearTimeout)(this[kMonitorId]);\n    this[kConnection]?.destroy({\n      force: true\n    });\n    this[kConnection] = undefined;\n  }\n}\nexports.RTTPinger = RTTPinger;\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = (0, utils_1.now)();\n  options.cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n  if (rttPinger.closed) {\n    return;\n  }\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn?.destroy({\n        force: true\n      });\n      return;\n    }\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n    rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);\n    rttPinger[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n  const connection = rttPinger[kConnection];\n  if (connection == null) {\n    (0, connect_1.connect)(options, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n  connection.command((0, utils_1.ns)('admin.$cmd'), {\n    [constants_1.LEGACY_HELLO_COMMAND]: 1\n  }, undefined, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n    measureAndReschedule();\n  });\n}\n/**\r\n * @internal\r\n */\nclass MonitorInterval {\n  constructor(fn, options = {}) {\n    this.isExpeditedCallToFnScheduled = false;\n    this.stopped = false;\n    this.isExecutionInProgress = false;\n    this.hasExecutedOnce = false;\n    this._executeAndReschedule = () => {\n      if (this.stopped) return;\n      if (this.timerId) {\n        (0, timers_1.clearTimeout)(this.timerId);\n      }\n      this.isExpeditedCallToFnScheduled = false;\n      this.isExecutionInProgress = true;\n      this.fn(() => {\n        this.lastExecutionEnded = (0, utils_1.now)();\n        this.isExecutionInProgress = false;\n        this._reschedule(this.heartbeatFrequencyMS);\n      });\n    };\n    this.fn = fn;\n    this.lastExecutionEnded = -Infinity;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;\n    this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;\n    if (options.immediate) {\n      this._executeAndReschedule();\n    } else {\n      this._reschedule(undefined);\n    }\n  }\n  wake() {\n    const currentTime = (0, utils_1.now)();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n    // TODO(NODE-4674): Add error handling and logging to the monitor\n    if (timeSinceLastCall < 0) {\n      return this._executeAndReschedule();\n    }\n    if (this.isExecutionInProgress) {\n      return;\n    }\n    // debounce multiple calls to wake within the `minInterval`\n    if (this.isExpeditedCallToFnScheduled) {\n      return;\n    }\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {\n      this.isExpeditedCallToFnScheduled = true;\n      this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);\n      return;\n    }\n    this._executeAndReschedule();\n  }\n  stop() {\n    this.stopped = true;\n    if (this.timerId) {\n      (0, timers_1.clearTimeout)(this.timerId);\n      this.timerId = undefined;\n    }\n    this.lastExecutionEnded = -Infinity;\n    this.isExpeditedCallToFnScheduled = false;\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toJSON() {\n    const currentTime = (0, utils_1.now)();\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n    return {\n      timerId: this.timerId != null ? 'set' : 'cleared',\n      lastCallTime: this.lastExecutionEnded,\n      isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,\n      stopped: this.stopped,\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,\n      currentTime,\n      timeSinceLastCall\n    };\n  }\n  _reschedule(ms) {\n    if (this.stopped) return;\n    if (this.timerId) {\n      (0, timers_1.clearTimeout)(this.timerId);\n    }\n    this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\n  }\n}\nexports.MonitorInterval = MonitorInterval;","map":{"version":3,"mappings":"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","names":["kServer","Symbol","kMonitorId","kConnection","kCancellationToken","kRTTPinger","kRoundTripTime","STATE_IDLE","STATE_MONITORING","stateTransition","common_1","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","Monitor","mongo_types_1","connection","constructor","server","options","undefined","setMaxListeners","Infinity","address","description","Object","freeze","connectTimeoutMS","heartbeatFrequencyMS","minHeartbeatFrequencyMS","cancellationToken","connectOptions","assign","id","generation","pool","connectionType","connection_1","hostAddress","raw","useBigInt64","promoteLongs","promoteValues","promoteBuffers","credentials","autoEncrypter","connect","MonitorInterval","monitorServer","immediate","requestCheck","has","wake","reset","topologyVersion","resetMonitorState","close","emit","exports","stop","destroy","force","checkServer","callback","start","server_1","SERVER_HEARTBEAT_STARTED","events_1","failureHandler","err","SERVER_HEARTBEAT_FAILED","error","error_1","addErrorLabel","ResetPool","InterruptInUseConnections","closed","serverApi","helloOk","maxAwaitTimeMS","isAwaitable","cmd","version","constants_1","makeTopologyVersion","socketTimeoutMS","exhaustAllowed","RTTPinger","command","hello","isWritablePrimary","rttPinger","duration","roundTripTime","SERVER_HEARTBEAT_SUCCEEDED","conn","isMonitoringConnection","process","nextTick","done","type","Unknown","tv","processId","counter","bson_1","isLong","fromNumber","measureRoundTripTime","measureAndReschedule","fn","stopped","timerId","isExpeditedCallToFnScheduled","isExecutionInProgress","lastExecutionEnded","_reschedule","_executeAndReschedule","currentTime","timeSinceLastCall","toString","JSON","stringify","toJSON","lastCallTime","isExpeditedCheckScheduled","ms"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\sdam\\monitor.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\r\n\r\nimport { type Document, Long } from '../bson';\r\nimport { connect } from '../cmap/connect';\r\nimport { Connection, type ConnectionOptions } from '../cmap/connection';\r\nimport { LEGACY_HELLO_COMMAND } from '../constants';\r\nimport { MongoError, MongoErrorLabel, MongoNetworkTimeoutError } from '../error';\r\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\r\nimport type { Callback, EventEmitterWithState } from '../utils';\r\nimport { calculateDurationInMs, makeStateMachine, now, ns } from '../utils';\r\nimport { ServerType, STATE_CLOSED, STATE_CLOSING } from './common';\r\nimport {\r\n  ServerHeartbeatFailedEvent,\r\n  ServerHeartbeatStartedEvent,\r\n  ServerHeartbeatSucceededEvent\r\n} from './events';\r\nimport { Server } from './server';\r\nimport type { TopologyVersion } from './server_description';\r\n\r\n/** @internal */\r\nconst kServer = Symbol('server');\r\n/** @internal */\r\nconst kMonitorId = Symbol('monitorId');\r\n/** @internal */\r\nconst kConnection = Symbol('connection');\r\n/** @internal */\r\nconst kCancellationToken = Symbol('cancellationToken');\r\n/** @internal */\r\nconst kRTTPinger = Symbol('rttPinger');\r\n/** @internal */\r\nconst kRoundTripTime = Symbol('roundTripTime');\r\n\r\nconst STATE_IDLE = 'idle';\r\nconst STATE_MONITORING = 'monitoring';\r\nconst stateTransition = makeStateMachine({\r\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\r\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\r\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\r\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\r\n});\r\n\r\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\r\nfunction isInCloseState(monitor: Monitor) {\r\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\r\n}\r\n\r\n/** @internal */\r\nexport interface MonitorPrivate {\r\n  state: string;\r\n}\r\n\r\n/** @public */\r\nexport interface MonitorOptions\r\n  extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {\r\n  connectTimeoutMS: number;\r\n  heartbeatFrequencyMS: number;\r\n  minHeartbeatFrequencyMS: number;\r\n}\r\n\r\n/** @public */\r\nexport type MonitorEvents = {\r\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\r\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\r\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\r\n  resetServer(error?: MongoError): void;\r\n  resetConnectionPool(): void;\r\n  close(): void;\r\n} & EventEmitterWithState;\r\n\r\n/** @internal */\r\nexport class Monitor extends TypedEventEmitter<MonitorEvents> {\r\n  /** @internal */\r\n  s: MonitorPrivate;\r\n  address: string;\r\n  options: Readonly<\r\n    Pick<MonitorOptions, 'connectTimeoutMS' | 'heartbeatFrequencyMS' | 'minHeartbeatFrequencyMS'>\r\n  >;\r\n  connectOptions: ConnectionOptions;\r\n  [kServer]: Server;\r\n  [kConnection]?: Connection;\r\n  [kCancellationToken]: CancellationToken;\r\n  /** @internal */\r\n  [kMonitorId]?: MonitorInterval;\r\n  [kRTTPinger]?: RTTPinger;\r\n\r\n  get connection(): Connection | undefined {\r\n    return this[kConnection];\r\n  }\r\n\r\n  constructor(server: Server, options: MonitorOptions) {\r\n    super();\r\n\r\n    this[kServer] = server;\r\n    this[kConnection] = undefined;\r\n    this[kCancellationToken] = new CancellationToken();\r\n    this[kCancellationToken].setMaxListeners(Infinity);\r\n    this[kMonitorId] = undefined;\r\n    this.s = {\r\n      state: STATE_CLOSED\r\n    };\r\n\r\n    this.address = server.description.address;\r\n    this.options = Object.freeze({\r\n      connectTimeoutMS: options.connectTimeoutMS ?? 10000,\r\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\r\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500\r\n    });\r\n\r\n    const cancellationToken = this[kCancellationToken];\r\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\r\n    const connectOptions = Object.assign(\r\n      {\r\n        id: '<monitor>' as const,\r\n        generation: server.pool.generation,\r\n        connectionType: Connection,\r\n        cancellationToken,\r\n        hostAddress: server.description.hostAddress\r\n      },\r\n      options,\r\n      // force BSON serialization options\r\n      {\r\n        raw: false,\r\n        useBigInt64: false,\r\n        promoteLongs: true,\r\n        promoteValues: true,\r\n        promoteBuffers: true\r\n      }\r\n    );\r\n\r\n    // ensure no authentication is used for monitoring\r\n    delete connectOptions.credentials;\r\n    if (connectOptions.autoEncrypter) {\r\n      delete connectOptions.autoEncrypter;\r\n    }\r\n\r\n    this.connectOptions = Object.freeze(connectOptions);\r\n  }\r\n\r\n  connect(): void {\r\n    if (this.s.state !== STATE_CLOSED) {\r\n      return;\r\n    }\r\n\r\n    // start\r\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\r\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\r\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\r\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\r\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\r\n      immediate: true\r\n    });\r\n  }\r\n\r\n  requestCheck(): void {\r\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\r\n      return;\r\n    }\r\n\r\n    this[kMonitorId]?.wake();\r\n  }\r\n\r\n  reset(): void {\r\n    const topologyVersion = this[kServer].description.topologyVersion;\r\n    if (isInCloseState(this) || topologyVersion == null) {\r\n      return;\r\n    }\r\n\r\n    stateTransition(this, STATE_CLOSING);\r\n    resetMonitorState(this);\r\n\r\n    // restart monitor\r\n    stateTransition(this, STATE_IDLE);\r\n\r\n    // restart monitoring\r\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\r\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\r\n    this[kMonitorId] = new MonitorInterval(monitorServer(this), {\r\n      heartbeatFrequencyMS: heartbeatFrequencyMS,\r\n      minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\r\n    });\r\n  }\r\n\r\n  close(): void {\r\n    if (isInCloseState(this)) {\r\n      return;\r\n    }\r\n\r\n    stateTransition(this, STATE_CLOSING);\r\n    resetMonitorState(this);\r\n\r\n    // close monitor\r\n    this.emit('close');\r\n    stateTransition(this, STATE_CLOSED);\r\n  }\r\n}\r\n\r\nfunction resetMonitorState(monitor: Monitor) {\r\n  monitor[kMonitorId]?.stop();\r\n  monitor[kMonitorId] = undefined;\r\n\r\n  monitor[kRTTPinger]?.close();\r\n  monitor[kRTTPinger] = undefined;\r\n\r\n  monitor[kCancellationToken].emit('cancel');\r\n\r\n  monitor[kConnection]?.destroy({ force: true });\r\n  monitor[kConnection] = undefined;\r\n}\r\n\r\nfunction checkServer(monitor: Monitor, callback: Callback<Document | null>) {\r\n  let start = now();\r\n  monitor.emit(Server.SERVER_HEARTBEAT_STARTED, new ServerHeartbeatStartedEvent(monitor.address));\r\n\r\n  function failureHandler(err: Error) {\r\n    monitor[kConnection]?.destroy({ force: true });\r\n    monitor[kConnection] = undefined;\r\n\r\n    monitor.emit(\r\n      Server.SERVER_HEARTBEAT_FAILED,\r\n      new ServerHeartbeatFailedEvent(monitor.address, calculateDurationInMs(start), err)\r\n    );\r\n\r\n    const error = !(err instanceof MongoError) ? new MongoError(err) : err;\r\n    error.addErrorLabel(MongoErrorLabel.ResetPool);\r\n    if (error instanceof MongoNetworkTimeoutError) {\r\n      error.addErrorLabel(MongoErrorLabel.InterruptInUseConnections);\r\n    }\r\n\r\n    monitor.emit('resetServer', error);\r\n    callback(err);\r\n  }\r\n\r\n  const connection = monitor[kConnection];\r\n  if (connection && !connection.closed) {\r\n    const { serverApi, helloOk } = connection;\r\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\r\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\r\n    const topologyVersion = monitor[kServer].description.topologyVersion;\r\n    const isAwaitable = topologyVersion != null;\r\n\r\n    const cmd = {\r\n      [serverApi?.version || helloOk ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\r\n      ...(isAwaitable && topologyVersion\r\n        ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\r\n        : {})\r\n    };\r\n\r\n    const options = isAwaitable\r\n      ? {\r\n          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\r\n          exhaustAllowed: true\r\n        }\r\n      : { socketTimeoutMS: connectTimeoutMS };\r\n\r\n    if (isAwaitable && monitor[kRTTPinger] == null) {\r\n      monitor[kRTTPinger] = new RTTPinger(\r\n        monitor[kCancellationToken],\r\n        Object.assign(\r\n          { heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS },\r\n          monitor.connectOptions\r\n        )\r\n      );\r\n    }\r\n\r\n    connection.command(ns('admin.$cmd'), cmd, options, (err, hello) => {\r\n      if (err) {\r\n        return failureHandler(err);\r\n      }\r\n\r\n      if (!('isWritablePrimary' in hello)) {\r\n        // Provide hello-style response document.\r\n        hello.isWritablePrimary = hello[LEGACY_HELLO_COMMAND];\r\n      }\r\n\r\n      const rttPinger = monitor[kRTTPinger];\r\n      const duration =\r\n        isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);\r\n\r\n      monitor.emit(\r\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\r\n        new ServerHeartbeatSucceededEvent(monitor.address, duration, hello)\r\n      );\r\n\r\n      // if we are using the streaming protocol then we immediately issue another `started`\r\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\r\n      if (isAwaitable && hello.topologyVersion) {\r\n        monitor.emit(\r\n          Server.SERVER_HEARTBEAT_STARTED,\r\n          new ServerHeartbeatStartedEvent(monitor.address)\r\n        );\r\n        start = now();\r\n      } else {\r\n        monitor[kRTTPinger]?.close();\r\n        monitor[kRTTPinger] = undefined;\r\n\r\n        callback(undefined, hello);\r\n      }\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  // connecting does an implicit `hello`\r\n  connect(monitor.connectOptions, (err, conn) => {\r\n    if (err) {\r\n      monitor[kConnection] = undefined;\r\n\r\n      failureHandler(err);\r\n      return;\r\n    }\r\n\r\n    if (conn) {\r\n      // Tell the connection that we are using the streaming protocol so that the\r\n      // connection's message stream will only read the last hello on the buffer.\r\n      conn.isMonitoringConnection = true;\r\n\r\n      if (isInCloseState(monitor)) {\r\n        conn.destroy({ force: true });\r\n        return;\r\n      }\r\n\r\n      monitor[kConnection] = conn;\r\n      monitor.emit(\r\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\r\n        new ServerHeartbeatSucceededEvent(monitor.address, calculateDurationInMs(start), conn.hello)\r\n      );\r\n\r\n      callback(undefined, conn.hello);\r\n    }\r\n  });\r\n}\r\n\r\nfunction monitorServer(monitor: Monitor) {\r\n  return (callback: Callback) => {\r\n    if (monitor.s.state === STATE_MONITORING) {\r\n      process.nextTick(callback);\r\n      return;\r\n    }\r\n    stateTransition(monitor, STATE_MONITORING);\r\n    function done() {\r\n      if (!isInCloseState(monitor)) {\r\n        stateTransition(monitor, STATE_IDLE);\r\n      }\r\n\r\n      callback();\r\n    }\r\n\r\n    checkServer(monitor, (err, hello) => {\r\n      if (err) {\r\n        // otherwise an error occurred on initial discovery, also bail\r\n        if (monitor[kServer].description.type === ServerType.Unknown) {\r\n          return done();\r\n        }\r\n      }\r\n\r\n      // if the check indicates streaming is supported, immediately reschedule monitoring\r\n      if (hello && hello.topologyVersion) {\r\n        setTimeout(() => {\r\n          if (!isInCloseState(monitor)) {\r\n            monitor[kMonitorId]?.wake();\r\n          }\r\n        }, 0);\r\n      }\r\n\r\n      done();\r\n    });\r\n  };\r\n}\r\n\r\nfunction makeTopologyVersion(tv: TopologyVersion) {\r\n  return {\r\n    processId: tv.processId,\r\n    // tests mock counter as just number, but in a real situation counter should always be a Long\r\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\r\n    counter: Long.isLong(tv.counter) ? tv.counter : Long.fromNumber(tv.counter)\r\n  };\r\n}\r\n\r\n/** @internal */\r\nexport interface RTTPingerOptions extends ConnectionOptions {\r\n  heartbeatFrequencyMS: number;\r\n}\r\n\r\n/** @internal */\r\nexport class RTTPinger {\r\n  /** @internal */\r\n  [kConnection]?: Connection;\r\n  /** @internal */\r\n  [kCancellationToken]: CancellationToken;\r\n  /** @internal */\r\n  [kRoundTripTime]: number;\r\n  /** @internal */\r\n  [kMonitorId]: NodeJS.Timeout;\r\n  closed: boolean;\r\n\r\n  constructor(cancellationToken: CancellationToken, options: RTTPingerOptions) {\r\n    this[kConnection] = undefined;\r\n    this[kCancellationToken] = cancellationToken;\r\n    this[kRoundTripTime] = 0;\r\n    this.closed = false;\r\n\r\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\r\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\r\n  }\r\n\r\n  get roundTripTime(): number {\r\n    return this[kRoundTripTime];\r\n  }\r\n\r\n  close(): void {\r\n    this.closed = true;\r\n    clearTimeout(this[kMonitorId]);\r\n\r\n    this[kConnection]?.destroy({ force: true });\r\n    this[kConnection] = undefined;\r\n  }\r\n}\r\n\r\nfunction measureRoundTripTime(rttPinger: RTTPinger, options: RTTPingerOptions) {\r\n  const start = now();\r\n  options.cancellationToken = rttPinger[kCancellationToken];\r\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\r\n\r\n  if (rttPinger.closed) {\r\n    return;\r\n  }\r\n\r\n  function measureAndReschedule(conn?: Connection) {\r\n    if (rttPinger.closed) {\r\n      conn?.destroy({ force: true });\r\n      return;\r\n    }\r\n\r\n    if (rttPinger[kConnection] == null) {\r\n      rttPinger[kConnection] = conn;\r\n    }\r\n\r\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\r\n    rttPinger[kMonitorId] = setTimeout(\r\n      () => measureRoundTripTime(rttPinger, options),\r\n      heartbeatFrequencyMS\r\n    );\r\n  }\r\n\r\n  const connection = rttPinger[kConnection];\r\n  if (connection == null) {\r\n    connect(options, (err, conn) => {\r\n      if (err) {\r\n        rttPinger[kConnection] = undefined;\r\n        rttPinger[kRoundTripTime] = 0;\r\n        return;\r\n      }\r\n\r\n      measureAndReschedule(conn);\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  connection.command(ns('admin.$cmd'), { [LEGACY_HELLO_COMMAND]: 1 }, undefined, err => {\r\n    if (err) {\r\n      rttPinger[kConnection] = undefined;\r\n      rttPinger[kRoundTripTime] = 0;\r\n      return;\r\n    }\r\n\r\n    measureAndReschedule();\r\n  });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface MonitorIntervalOptions {\r\n  /** The interval to execute a method on */\r\n  heartbeatFrequencyMS: number;\r\n  /** A minimum interval that must elapse before the method is called */\r\n  minHeartbeatFrequencyMS: number;\r\n  /** Whether the method should be called immediately when the interval is started  */\r\n  immediate: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MonitorInterval {\r\n  fn: (callback: Callback) => void;\r\n  timerId: NodeJS.Timeout | undefined;\r\n  lastExecutionEnded: number;\r\n  isExpeditedCallToFnScheduled = false;\r\n  stopped = false;\r\n  isExecutionInProgress = false;\r\n  hasExecutedOnce = false;\r\n\r\n  heartbeatFrequencyMS: number;\r\n  minHeartbeatFrequencyMS: number;\r\n\r\n  constructor(fn: (callback: Callback) => void, options: Partial<MonitorIntervalOptions> = {}) {\r\n    this.fn = fn;\r\n    this.lastExecutionEnded = -Infinity;\r\n\r\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;\r\n    this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;\r\n\r\n    if (options.immediate) {\r\n      this._executeAndReschedule();\r\n    } else {\r\n      this._reschedule(undefined);\r\n    }\r\n  }\r\n\r\n  wake() {\r\n    const currentTime = now();\r\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\r\n\r\n    // TODO(NODE-4674): Add error handling and logging to the monitor\r\n    if (timeSinceLastCall < 0) {\r\n      return this._executeAndReschedule();\r\n    }\r\n\r\n    if (this.isExecutionInProgress) {\r\n      return;\r\n    }\r\n\r\n    // debounce multiple calls to wake within the `minInterval`\r\n    if (this.isExpeditedCallToFnScheduled) {\r\n      return;\r\n    }\r\n\r\n    // reschedule a call as soon as possible, ensuring the call never happens\r\n    // faster than the `minInterval`\r\n    if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {\r\n      this.isExpeditedCallToFnScheduled = true;\r\n      this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);\r\n      return;\r\n    }\r\n\r\n    this._executeAndReschedule();\r\n  }\r\n\r\n  stop() {\r\n    this.stopped = true;\r\n    if (this.timerId) {\r\n      clearTimeout(this.timerId);\r\n      this.timerId = undefined;\r\n    }\r\n\r\n    this.lastExecutionEnded = -Infinity;\r\n    this.isExpeditedCallToFnScheduled = false;\r\n  }\r\n\r\n  toString() {\r\n    return JSON.stringify(this);\r\n  }\r\n\r\n  toJSON() {\r\n    const currentTime = now();\r\n    const timeSinceLastCall = currentTime - this.lastExecutionEnded;\r\n    return {\r\n      timerId: this.timerId != null ? 'set' : 'cleared',\r\n      lastCallTime: this.lastExecutionEnded,\r\n      isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,\r\n      stopped: this.stopped,\r\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\r\n      minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,\r\n      currentTime,\r\n      timeSinceLastCall\r\n    };\r\n  }\r\n\r\n  private _reschedule(ms?: number) {\r\n    if (this.stopped) return;\r\n    if (this.timerId) {\r\n      clearTimeout(this.timerId);\r\n    }\r\n\r\n    this.timerId = setTimeout(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\r\n  }\r\n\r\n  private _executeAndReschedule = () => {\r\n    if (this.stopped) return;\r\n    if (this.timerId) {\r\n      clearTimeout(this.timerId);\r\n    }\r\n\r\n    this.isExpeditedCallToFnScheduled = false;\r\n    this.isExecutionInProgress = true;\r\n\r\n    this.fn(() => {\r\n      this.lastExecutionEnded = now();\r\n      this.isExecutionInProgress = false;\r\n      this._reschedule(this.heartbeatFrequencyMS);\r\n    });\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}