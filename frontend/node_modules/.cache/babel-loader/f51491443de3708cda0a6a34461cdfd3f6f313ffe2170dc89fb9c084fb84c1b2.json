{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(client, operation, callback) {\n  return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback);\n}\nexports.executeOperation = executeOperation;\nasync function executeOperationAsync(client, operation) {\n  if (!(operation instanceof operation_1.AbstractCallbackOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  if (client.topology == null) {\n    // Auto connect on operation\n    if (client.s.hasBeenClosed) {\n      throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n  const {\n    topology\n  } = client;\n  if (topology == null) {\n    throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n  }\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner;\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({\n      owner,\n      explicit: false\n    });\n  } else if (session.hasEnded) {\n    throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  }\n  const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n  }\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  let selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  const server = await topology.selectServerAsync(selector, {\n    session\n  });\n  if (session == null) {\n    // No session also means it is not retryable, early exit\n    return operation.execute(server, undefined);\n  }\n  if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n    // non-retryable operation, early exit\n    try {\n      return await operation.execute(server, session);\n    } finally {\n      if (session?.owner != null && session.owner === owner) {\n        await session.endSession().catch(() => null);\n      }\n    }\n  }\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n  const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;\n  if (hasWriteAspect && willRetryWrite) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n  try {\n    return await operation.execute(server, session);\n  } catch (operationError) {\n    if (willRetry && operationError instanceof error_1.MongoError) {\n      return await retryOperation(operation, operationError, {\n        session,\n        topology,\n        selector\n      });\n    }\n    throw operationError;\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession().catch(() => null);\n    }\n  }\n}\nasync function retryOperation(operation, originalError, {\n  session,\n  topology,\n  selector\n}) {\n  const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n    throw new error_1.MongoServerError({\n      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      originalError\n    });\n  }\n  if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n    throw originalError;\n  }\n  if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n    throw originalError;\n  }\n  if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n    // If we have a cursor and the initial command fails with a network error,\n    // we can retry it on another connection. So we need to check it back in, clear the\n    // pool for the service id, and retry again.\n    session.unpin({\n      force: true,\n      forceClear: true\n    });\n  }\n  // select a new server, and attempt to retry the operation\n  const server = await topology.selectServerAsync(selector, {\n    session\n  });\n  if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n    throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n  }\n  try {\n    return await operation.execute(server, session);\n  } catch (retryError) {\n    if (retryError instanceof error_1.MongoError && retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n      throw originalError;\n    }\n    throw retryError;\n  }\n}","map":{"version":3,"mappings":"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","names":["MMAPv1_RETRY_WRITES_ERROR_CODE","error_1","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","client","operation","callback","executeOperationAsync","exports","operation_1","topology","s","hasBeenClosed","options","Symbol","for","connect","session","owner","startSession","explicit","hasEnded","snapshotEnabled","capabilities","supportsSnapshotReads","readPreference","read_preference_1","primary","inTransaction","equals","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","selector","hasAspect","MUST_SELECT_SAME_SERVER","server","description","trySecondaryWrite","commonWireVersion","selectServerAsync","execute","undefined","RETRYABLE","endSession","catch","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","canRetryWrite","hasReadAspect","READ_OPERATION","hasWriteAspect","WRITE_OPERATION","willRetry","incrementTransactionNumber","operationError","retryOperation","originalError","isWriteOperation","isReadOperation","code","message","errmsg","CURSOR_CREATING","force","forceClear","retryError","hasErrorLabel","NoWritesPerformed"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\operations\\execute_operation.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport {\r\n  isRetryableReadError,\r\n  isRetryableWriteError,\r\n  MongoCompatibilityError,\r\n  MONGODB_ERROR_CODES,\r\n  MongoError,\r\n  MongoErrorLabel,\r\n  MongoExpiredSessionError,\r\n  MongoNetworkError,\r\n  MongoNotConnectedError,\r\n  MongoRuntimeError,\r\n  MongoServerError,\r\n  MongoTransactionError,\r\n  MongoUnexpectedServerResponseError\r\n} from '../error';\r\nimport type { MongoClient } from '../mongo_client';\r\nimport { ReadPreference } from '../read_preference';\r\nimport type { Server } from '../sdam/server';\r\nimport {\r\n  sameServerSelector,\r\n  secondaryWritableServerSelector,\r\n  type ServerSelector\r\n} from '../sdam/server_selection';\r\nimport type { Topology } from '../sdam/topology';\r\nimport type { ClientSession } from '../sessions';\r\nimport { type Callback, maybeCallback, supportsRetryableWrites } from '../utils';\r\nimport { AbstractCallbackOperation, Aspect } from './operation';\r\n\r\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\r\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\r\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\r\n\r\ntype ResultTypeFromOperation<TOperation> = TOperation extends AbstractCallbackOperation<infer K>\r\n  ? K\r\n  : never;\r\n\r\n/** @internal */\r\nexport interface ExecutionResult {\r\n  /** The server selected for the operation */\r\n  server: Server;\r\n  /** The session used for this operation, may be implicitly created */\r\n  session?: ClientSession;\r\n  /** The raw server response for the operation */\r\n  response: Document;\r\n}\r\n\r\n/**\r\n * Executes the given operation with provided arguments.\r\n * @internal\r\n *\r\n * @remarks\r\n * This method reduces large amounts of duplication in the entire codebase by providing\r\n * a single point for determining whether callbacks or promises should be used. Additionally\r\n * it allows for a single point of entry to provide features such as implicit sessions, which\r\n * are required by the Driver Sessions specification in the event that a ClientSession is\r\n * not provided\r\n *\r\n * @param topology - The topology to execute this operation on\r\n * @param operation - The operation to execute\r\n * @param callback - The command result callback\r\n */\r\nexport function executeOperation<\r\n  T extends AbstractCallbackOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(client: MongoClient, operation: T): Promise<TResult>;\r\nexport function executeOperation<\r\n  T extends AbstractCallbackOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(client: MongoClient, operation: T, callback: Callback<TResult>): void;\r\nexport function executeOperation<\r\n  T extends AbstractCallbackOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;\r\nexport function executeOperation<\r\n  T extends AbstractCallbackOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void {\r\n  return maybeCallback(() => executeOperationAsync(client, operation), callback);\r\n}\r\n\r\nasync function executeOperationAsync<\r\n  T extends AbstractCallbackOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(client: MongoClient, operation: T): Promise<TResult> {\r\n  if (!(operation instanceof AbstractCallbackOperation)) {\r\n    // TODO(NODE-3483): Extend MongoRuntimeError\r\n    throw new MongoRuntimeError('This method requires a valid operation instance');\r\n  }\r\n\r\n  if (client.topology == null) {\r\n    // Auto connect on operation\r\n    if (client.s.hasBeenClosed) {\r\n      throw new MongoNotConnectedError('Client must be connected before running operations');\r\n    }\r\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\r\n    try {\r\n      await client.connect();\r\n    } finally {\r\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\r\n    }\r\n  }\r\n\r\n  const { topology } = client;\r\n  if (topology == null) {\r\n    throw new MongoRuntimeError('client.connect did not create a topology but also did not throw');\r\n  }\r\n\r\n  // The driver sessions spec mandates that we implicitly create sessions for operations\r\n  // that are not explicitly provided with a session.\r\n  let session = operation.session;\r\n  let owner: symbol | undefined;\r\n\r\n  if (session == null) {\r\n    owner = Symbol();\r\n    session = client.startSession({ owner, explicit: false });\r\n  } else if (session.hasEnded) {\r\n    throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\r\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\r\n    throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\r\n  }\r\n\r\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\r\n  const inTransaction = !!session?.inTransaction();\r\n\r\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\r\n    throw new MongoTransactionError(\r\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\r\n    );\r\n  }\r\n\r\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\r\n    session.unpin();\r\n  }\r\n\r\n  let selector: ReadPreference | ServerSelector;\r\n\r\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\r\n    // GetMore and KillCursor operations must always select the same server, but run through\r\n    // server selection to potentially force monitor checks if the server is\r\n    // in an unknown state.\r\n    selector = sameServerSelector(operation.server?.description);\r\n  } else if (operation.trySecondaryWrite) {\r\n    // If operation should try to write to secondary use the custom server selector\r\n    // otherwise provide the read preference.\r\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\r\n  } else {\r\n    selector = readPreference;\r\n  }\r\n\r\n  const server = await topology.selectServerAsync(selector, { session });\r\n\r\n  if (session == null) {\r\n    // No session also means it is not retryable, early exit\r\n    return operation.execute(server, undefined);\r\n  }\r\n\r\n  if (!operation.hasAspect(Aspect.RETRYABLE)) {\r\n    // non-retryable operation, early exit\r\n    try {\r\n      return await operation.execute(server, session);\r\n    } finally {\r\n      if (session?.owner != null && session.owner === owner) {\r\n        await session.endSession().catch(() => null);\r\n      }\r\n    }\r\n  }\r\n\r\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\r\n\r\n  const willRetryWrite =\r\n    topology.s.options.retryWrites &&\r\n    !inTransaction &&\r\n    supportsRetryableWrites(server) &&\r\n    operation.canRetryWrite;\r\n\r\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\r\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\r\n  const willRetry = (hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite);\r\n\r\n  if (hasWriteAspect && willRetryWrite) {\r\n    operation.options.willRetryWrite = true;\r\n    session.incrementTransactionNumber();\r\n  }\r\n\r\n  try {\r\n    return await operation.execute(server, session);\r\n  } catch (operationError) {\r\n    if (willRetry && operationError instanceof MongoError) {\r\n      return await retryOperation(operation, operationError, {\r\n        session,\r\n        topology,\r\n        selector\r\n      });\r\n    }\r\n    throw operationError;\r\n  } finally {\r\n    if (session?.owner != null && session.owner === owner) {\r\n      await session.endSession().catch(() => null);\r\n    }\r\n  }\r\n}\r\n\r\n/** @internal */\r\ntype RetryOptions = {\r\n  session: ClientSession;\r\n  topology: Topology;\r\n  selector: ReadPreference | ServerSelector;\r\n};\r\n\r\nasync function retryOperation<\r\n  T extends AbstractCallbackOperation<TResult>,\r\n  TResult = ResultTypeFromOperation<T>\r\n>(\r\n  operation: T,\r\n  originalError: MongoError,\r\n  { session, topology, selector }: RetryOptions\r\n): Promise<TResult> {\r\n  const isWriteOperation = operation.hasAspect(Aspect.WRITE_OPERATION);\r\n  const isReadOperation = operation.hasAspect(Aspect.READ_OPERATION);\r\n\r\n  if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\r\n    throw new MongoServerError({\r\n      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\r\n      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\r\n      originalError\r\n    });\r\n  }\r\n\r\n  if (isWriteOperation && !isRetryableWriteError(originalError)) {\r\n    throw originalError;\r\n  }\r\n\r\n  if (isReadOperation && !isRetryableReadError(originalError)) {\r\n    throw originalError;\r\n  }\r\n\r\n  if (\r\n    originalError instanceof MongoNetworkError &&\r\n    session.isPinned &&\r\n    !session.inTransaction() &&\r\n    operation.hasAspect(Aspect.CURSOR_CREATING)\r\n  ) {\r\n    // If we have a cursor and the initial command fails with a network error,\r\n    // we can retry it on another connection. So we need to check it back in, clear the\r\n    // pool for the service id, and retry again.\r\n    session.unpin({ force: true, forceClear: true });\r\n  }\r\n\r\n  // select a new server, and attempt to retry the operation\r\n  const server = await topology.selectServerAsync(selector, { session });\r\n\r\n  if (isWriteOperation && !supportsRetryableWrites(server)) {\r\n    throw new MongoUnexpectedServerResponseError(\r\n      'Selected server does not support retryable writes'\r\n    );\r\n  }\r\n\r\n  try {\r\n    return await operation.execute(server, session);\r\n  } catch (retryError) {\r\n    if (\r\n      retryError instanceof MongoError &&\r\n      retryError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\r\n    ) {\r\n      throw originalError;\r\n    }\r\n    throw retryError;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}