{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst common_functions_1 = require(\"./common_functions\");\nconst operation_1 = require(\"./operation\");\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version',\n// text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion',\n// 2d-sphere indexes\n'2dsphereIndexVersion',\n// 2d indexes\n'bits', 'min', 'max',\n// geoHaystack Indexes\n'bucketSize',\n// wildcard indexes\n'wildcardProjection']);\nfunction isIndexDirection(x) {\n  return typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack';\n}\nfunction isSingleIndexTuple(t) {\n  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);\n}\nfunction makeIndexSpec(indexSpec, options) {\n  const key = new Map();\n  const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;\n  // Iterate through array and handle different types\n  for (const spec of indexSpecs) {\n    if (typeof spec === 'string') {\n      key.set(spec, 1);\n    } else if (Array.isArray(spec)) {\n      key.set(spec[0], spec[1] ?? 1);\n    } else if (spec instanceof Map) {\n      for (const [property, value] of spec) {\n        key.set(property, value);\n      }\n    } else if ((0, utils_1.isObject)(spec)) {\n      for (const [property, value] of Object.entries(spec)) {\n        key.set(property, value);\n      }\n    }\n  }\n  return {\n    ...options,\n    key\n  };\n}\n/** @internal */\nclass IndexesOperation extends operation_1.AbstractCallbackOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n  executeCallback(server, session, callback) {\n    const coll = this.collection;\n    const options = this.options;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {\n      full: true,\n      ...options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n}\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\nclass CreateIndexesOperation extends command_1.CommandCallbackOperation {\n  constructor(parent, collectionName, indexes, options) {\n    super(parent, options);\n    this.options = options ?? {};\n    this.collectionName = collectionName;\n    this.indexes = indexes.map(userIndex => {\n      // Ensure the key is a Map to preserve index key ordering\n      const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));\n      const name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join('_');\n      const validIndexOptions = Object.fromEntries(Object.entries({\n        ...userIndex\n      }).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName)));\n      return {\n        ...validIndexOptions,\n        name,\n        key\n      };\n    });\n  }\n  executeCallback(server, session, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const cmd = {\n      createIndexes: this.collectionName,\n      indexes\n    };\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n      cmd.commitQuorum = options.commitQuorum;\n    }\n    // collation is set on each index, it should not be defined at the root\n    this.options.collation = undefined;\n    super.executeCommandCallback(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames);\n    });\n  }\n}\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\nclass CreateIndexOperation extends CreateIndexesOperation {\n  constructor(parent, collectionName, indexSpec, options) {\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n  executeCallback(server, session, callback) {\n    super.executeCallback(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n}\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\nclass EnsureIndexOperation extends CreateIndexOperation {\n  constructor(db, collectionName, indexSpec, options) {\n    super(db, collectionName, indexSpec, options);\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n  executeCallback(server, session, callback) {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({\n      session\n    });\n    cursor.toArray().then(indexes => {\n      indexes = Array.isArray(indexes) ? indexes : [indexes];\n      if (indexes.some(index => index.name === indexName)) {\n        callback(undefined, indexName);\n        return;\n      }\n      super.executeCallback(server, session, callback);\n    }, error => {\n      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        // ignore \"NamespaceNotFound\" errors\n        return super.executeCallback(server, session, callback);\n      }\n      return callback(error);\n    });\n  }\n}\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\nclass DropIndexOperation extends command_1.CommandCallbackOperation {\n  constructor(collection, indexName, options) {\n    super(collection, options);\n    this.options = options ?? {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n  executeCallback(server, session, callback) {\n    const cmd = {\n      dropIndexes: this.collection.collectionName,\n      index: this.indexName\n    };\n    super.executeCommandCallback(server, session, cmd, callback);\n  }\n}\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\nclass DropIndexesOperation extends DropIndexOperation {\n  constructor(collection, options) {\n    super(collection, '*', options);\n  }\n  executeCallback(server, session, callback) {\n    super.executeCallback(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n}\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\nclass ListIndexesOperation extends command_1.CommandCallbackOperation {\n  constructor(collection, options) {\n    super(collection, options);\n    this.options = {\n      ...options\n    };\n    delete this.options.writeConcern;\n    this.collectionNamespace = collection.s.namespace;\n  }\n  executeCallback(server, session, callback) {\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const cursor = this.options.batchSize ? {\n      batchSize: this.options.batchSize\n    } : {};\n    const command = {\n      listIndexes: this.collectionNamespace.collection,\n      cursor\n    };\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n    super.executeCommandCallback(server, session, command, callback);\n  }\n}\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @internal */\nclass IndexExistsOperation extends operation_1.AbstractCallbackOperation {\n  constructor(collection, indexes, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n  executeCallback(server, session, callback) {\n    const coll = this.collection;\n    const indexes = this.indexes;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {\n      ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, (err, indexInformation) => {\n      // If we have an error return\n      if (err != null) return callback(err);\n      // Let's check for the index names\n      if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null);\n      // Check in list of indexes\n      for (let i = 0; i < indexes.length; i++) {\n        if (indexInformation[indexes[i]] == null) {\n          return callback(undefined, false);\n        }\n      }\n      // All keys found return true\n      return callback(undefined, true);\n    });\n  }\n}\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\nclass IndexInformationOperation extends operation_1.AbstractCallbackOperation {\n  constructor(db, name, options) {\n    super(options);\n    this.options = options ?? {};\n    this.db = db;\n    this.name = name;\n  }\n  executeCallback(server, session, callback) {\n    const db = this.db;\n    const name = this.name;\n    (0, common_functions_1.indexInformation)(db, name, {\n      ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n}\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":";;;;;;AAGA;AAEA;AAGA;AACA;AAMA;AACA;AAEA,MAAMA,mBAAmB,GAAG,IAAIC,GAAG,CAAC,CAClC,YAAY,EACZ,QAAQ,EACR,MAAM,EACN,yBAAyB,EACzB,QAAQ,EACR,QAAQ,EACR,oBAAoB,EACpB,eAAe,EACf,WAAW,EACX,SAAS;AAET;AACA,SAAS,EACT,kBAAkB,EAClB,mBAAmB,EACnB,kBAAkB;AAElB;AACA,sBAAsB;AAEtB;AACA,MAAM,EACN,KAAK,EACL,KAAK;AAEL;AACA,YAAY;AAEZ;AACA,oBAAoB,CACrB,CAAC;AAaF,SAASC,gBAAgB,CAACC,CAAU;EAClC,OACE,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK,UAAU,IAAIA,CAAC,KAAK,MAAM,IAAIA,CAAC,KAAK,aAAa;AAElG;AA8EA,SAASC,kBAAkB,CAACC,CAAU;EACpC,OAAOC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,IAAIA,CAAC,CAACG,MAAM,KAAK,CAAC,IAAIN,gBAAgB,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC;AACrE;AAEA,SAASI,aAAa,CACpBC,SAA6B,EAC7BC,OAA8B;EAE9B,MAAMC,GAAG,GAAgC,IAAIC,GAAG,EAAE;EAElD,MAAMC,UAAU,GACd,CAACR,KAAK,CAACC,OAAO,CAACG,SAAS,CAAC,IAAIN,kBAAkB,CAACM,SAAS,CAAC,GAAG,CAACA,SAAS,CAAC,GAAGA,SAAS;EAEtF;EACA,KAAK,MAAMK,IAAI,IAAID,UAAU,EAAE;IAC7B,IAAI,OAAOC,IAAI,KAAK,QAAQ,EAAE;MAC5BH,GAAG,CAACI,GAAG,CAACD,IAAI,EAAE,CAAC,CAAC;KACjB,MAAM,IAAIT,KAAK,CAACC,OAAO,CAACQ,IAAI,CAAC,EAAE;MAC9BH,GAAG,CAACI,GAAG,CAACD,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;KAC/B,MAAM,IAAIA,IAAI,YAAYF,GAAG,EAAE;MAC9B,KAAK,MAAM,CAACI,QAAQ,EAAEC,KAAK,CAAC,IAAIH,IAAI,EAAE;QACpCH,GAAG,CAACI,GAAG,CAACC,QAAQ,EAAEC,KAAK,CAAC;;KAE3B,MAAM,IAAI,oBAAQ,EAACH,IAAI,CAAC,EAAE;MACzB,KAAK,MAAM,CAACE,QAAQ,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACL,IAAI,CAAC,EAAE;QACpDH,GAAG,CAACI,GAAG,CAACC,QAAQ,EAAEC,KAAK,CAAC;;;;EAK9B,OAAO;IAAE,GAAGP,OAAO;IAAEC;EAAG,CAAE;AAC5B;AAEA;AACA,MAAaS,gBAAiB,SAAQC,qCAAqC;EAIzEC,YAAYC,UAAsB,EAAEb,OAAgC;IAClE,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACa,UAAU,GAAGA,UAAU;EAC9B;EAESC,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAA8B;IAE9B,MAAMC,IAAI,GAAG,IAAI,CAACL,UAAU;IAC5B,MAAMb,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5B,uCAAgB,EACdkB,IAAI,CAACC,CAAC,CAACC,EAAE,EACTF,IAAI,CAACG,cAAc,EACnB;MAAEC,IAAI,EAAE,IAAI;MAAE,GAAGtB,OAAO;MAAEuB,cAAc,EAAE,IAAI,CAACA,cAAc;MAAEP;IAAO,CAAE,EACxEC,QAAQ,CACT;EACH;;AAxBFO;AA2BA;AACA,MAAaC,sBAEX,SAAQC,kCAA2B;EAKnCd,YACEe,MAAuB,EACvBN,cAAsB,EACtBO,OAA2B,EAC3B5B,OAA8B;IAE9B,KAAK,CAAC2B,MAAM,EAAE3B,OAAO,CAAC;IAEtB,IAAI,CAACA,OAAO,GAAGA,OAAO,IAAI,EAAE;IAC5B,IAAI,CAACqB,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACO,OAAO,GAAGA,OAAO,CAACC,GAAG,CAACC,SAAS,IAAG;MACrC;MACA,MAAM7B,GAAG,GACP6B,SAAS,CAAC7B,GAAG,YAAYC,GAAG,GAAG4B,SAAS,CAAC7B,GAAG,GAAG,IAAIC,GAAG,CAACM,MAAM,CAACC,OAAO,CAACqB,SAAS,CAAC7B,GAAG,CAAC,CAAC;MACvF,MAAM8B,IAAI,GAAGD,SAAS,CAACC,IAAI,IAAI,IAAI,GAAGD,SAAS,CAACC,IAAI,GAAGpC,KAAK,CAACqC,IAAI,CAAC/B,GAAG,CAAC,CAACgC,IAAI,EAAE,CAACC,IAAI,CAAC,GAAG,CAAC;MACvF,MAAMC,iBAAiB,GAAG3B,MAAM,CAAC4B,WAAW,CAC1C5B,MAAM,CAACC,OAAO,CAAC;QAAE,GAAGqB;MAAS,CAAE,CAAC,CAACO,MAAM,CAAC,CAAC,CAACC,UAAU,CAAC,KACnDjD,mBAAmB,CAACkD,GAAG,CAACD,UAAU,CAAC,CACpC,CACF;MACD,OAAO;QACL,GAAGH,iBAAiB;QACpBJ,IAAI;QACJ9B;OACD;IACH,CAAC,CAAC;EACJ;EAESa,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAAqB;IAErB,MAAMjB,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAM4B,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5B,MAAMY,iBAAiB,GAAG,0BAAc,EAACzB,MAAM,CAAC;IAEhD,MAAM0B,GAAG,GAAa;MAAEC,aAAa,EAAE,IAAI,CAACrB,cAAc;MAAEO;IAAO,CAAE;IAErE,IAAI5B,OAAO,CAAC2C,YAAY,IAAI,IAAI,EAAE;MAChC,IAAIH,iBAAiB,GAAG,CAAC,EAAE;QACzBvB,QAAQ,CACN,IAAI2B,+BAAuB,CACzB,0EAA0E,CAC3E,CACF;QACD;;MAEFH,GAAG,CAACE,YAAY,GAAG3C,OAAO,CAAC2C,YAAY;;IAGzC;IACA,IAAI,CAAC3C,OAAO,CAAC6C,SAAS,GAAGC,SAAS;IAElC,KAAK,CAACC,sBAAsB,CAAChC,MAAM,EAAEC,OAAO,EAAEyB,GAAG,EAAEO,GAAG,IAAG;MACvD,IAAIA,GAAG,EAAE;QACP/B,QAAQ,CAAC+B,GAAG,CAAC;QACb;;MAGF,MAAMC,UAAU,GAAGrB,OAAO,CAACC,GAAG,CAACqB,KAAK,IAAIA,KAAK,CAACnB,IAAI,IAAI,EAAE,CAAC;MACzDd,QAAQ,CAAC6B,SAAS,EAAEG,UAAe,CAAC;IACtC,CAAC,CAAC;EACJ;;AAvEFzB;AA0EA;AACA,MAAa2B,oBAAqB,SAAQ1B,sBAA8B;EACtEb,YACEe,MAAuB,EACvBN,cAAsB,EACtBtB,SAA6B,EAC7BC,OAA8B;IAE9B,KAAK,CAAC2B,MAAM,EAAEN,cAAc,EAAE,CAACvB,aAAa,CAACC,SAAS,EAAEC,OAAO,CAAC,CAAC,EAAEA,OAAO,CAAC;EAC7E;EACSc,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAA0B;IAE1B,KAAK,CAACH,eAAe,CAACC,MAAM,EAAEC,OAAO,EAAE,CAACgC,GAAG,EAAEC,UAAU,KAAI;MACzD,IAAID,GAAG,IAAI,CAACC,UAAU,EAAE,OAAOhC,QAAQ,CAAC+B,GAAG,CAAC;MAC5C,OAAO/B,QAAQ,CAAC6B,SAAS,EAAEG,UAAU,CAAC,CAAC,CAAC,CAAC;IAC3C,CAAC,CAAC;EACJ;;AAlBFzB;AAqBA;AACA,MAAa4B,oBAAqB,SAAQD,oBAAoB;EAG5DvC,YACEQ,EAAM,EACNC,cAAsB,EACtBtB,SAA6B,EAC7BC,OAA8B;IAE9B,KAAK,CAACoB,EAAE,EAAEC,cAAc,EAAEtB,SAAS,EAAEC,OAAO,CAAC;IAE7C,IAAI,CAACuB,cAAc,GAAG8B,gCAAc,CAACC,OAAO;IAC5C,IAAI,CAAClC,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACC,cAAc,GAAGA,cAAc;EACtC;EAESP,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAAkB;IAElB,MAAMsC,SAAS,GAAG,IAAI,CAAC3B,OAAO,CAAC,CAAC,CAAC,CAACG,IAAI;IACtC,MAAMyB,MAAM,GAAG,IAAI,CAACpC,EAAE,CAACP,UAAU,CAAC,IAAI,CAACQ,cAAc,CAAC,CAACoC,WAAW,CAAC;MAAEzC;IAAO,CAAE,CAAC;IAC/EwC,MAAM,CAACE,OAAO,EAAE,CAACC,IAAI,CACnB/B,OAAO,IAAG;MACRA,OAAO,GAAGjC,KAAK,CAACC,OAAO,CAACgC,OAAO,CAAC,GAAGA,OAAO,GAAG,CAACA,OAAO,CAAC;MACtD,IAAIA,OAAO,CAACgC,IAAI,CAACV,KAAK,IAAIA,KAAK,CAACnB,IAAI,KAAKwB,SAAS,CAAC,EAAE;QACnDtC,QAAQ,CAAC6B,SAAS,EAAES,SAAS,CAAC;QAC9B;;MAEF,KAAK,CAACzC,eAAe,CAACC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,CAAC;IAClD,CAAC,EACD4C,KAAK,IAAG;MACN,IAAIA,KAAK,YAAYjB,kBAAU,IAAIiB,KAAK,CAACC,IAAI,KAAKlB,2BAAmB,CAACmB,iBAAiB,EAAE;QACvF;QACA,OAAO,KAAK,CAACjD,eAAe,CAACC,MAAM,EAAEC,OAAO,EAAEC,QAAQ,CAAC;;MAEzD,OAAOA,QAAQ,CAAC4C,KAAK,CAAC;IACxB,CAAC,CACF;EACH;;AAxCFrC;AA8CA;AACA,MAAawC,kBAAmB,SAAQtC,kCAAkC;EAKxEd,YAAYC,UAAsB,EAAE0C,SAAiB,EAAEvD,OAA4B;IACjF,KAAK,CAACa,UAAU,EAAEb,OAAO,CAAC;IAE1B,IAAI,CAACA,OAAO,GAAGA,OAAO,IAAI,EAAE;IAC5B,IAAI,CAACa,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAAC0C,SAAS,GAAGA,SAAS;EAC5B;EAESzC,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAA4B;IAE5B,MAAMwB,GAAG,GAAG;MAAEwB,WAAW,EAAE,IAAI,CAACpD,UAAU,CAACQ,cAAc;MAAE6B,KAAK,EAAE,IAAI,CAACK;IAAS,CAAE;IAClF,KAAK,CAACR,sBAAsB,CAAChC,MAAM,EAAEC,OAAO,EAAEyB,GAAG,EAAExB,QAAQ,CAAC;EAC9D;;AApBFO;AAuBA;AACA,MAAa0C,oBAAqB,SAAQF,kBAAkB;EAC1DpD,YAAYC,UAAsB,EAAEb,OAA2B;IAC7D,KAAK,CAACa,UAAU,EAAE,GAAG,EAAEb,OAAO,CAAC;EACjC;EAESc,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAAkB;IAElB,KAAK,CAACH,eAAe,CAACC,MAAM,EAAEC,OAAO,EAAEgC,GAAG,IAAG;MAC3C,IAAIA,GAAG,EAAE,OAAO/B,QAAQ,CAAC+B,GAAG,EAAE,KAAK,CAAC;MACpC/B,QAAQ,CAAC6B,SAAS,EAAE,IAAI,CAAC;IAC3B,CAAC,CAAC;EACJ;;AAdFtB;AAuBA;AACA,MAAa2C,oBAAqB,SAAQzC,kCAAkC;EAW1Ed,YAAYC,UAAsB,EAAEb,OAA4B;IAC9D,KAAK,CAACa,UAAU,EAAEb,OAAO,CAAC;IAE1B,IAAI,CAACA,OAAO,GAAG;MAAE,GAAGA;IAAO,CAAE;IAC7B,OAAO,IAAI,CAACA,OAAO,CAACoE,YAAY;IAChC,IAAI,CAACC,mBAAmB,GAAGxD,UAAU,CAACM,CAAC,CAACmD,SAAS;EACnD;EAESxD,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAA4B;IAE5B,MAAMuB,iBAAiB,GAAG,0BAAc,EAACzB,MAAM,CAAC;IAEhD,MAAMyC,MAAM,GAAG,IAAI,CAACxD,OAAO,CAACuE,SAAS,GAAG;MAAEA,SAAS,EAAE,IAAI,CAACvE,OAAO,CAACuE;IAAS,CAAE,GAAG,EAAE;IAElF,MAAMC,OAAO,GAAa;MAAEf,WAAW,EAAE,IAAI,CAACY,mBAAmB,CAACxD,UAAU;MAAE2C;IAAM,CAAE;IAEtF;IACA;IACA,IAAIhB,iBAAiB,IAAI,CAAC,IAAI,IAAI,CAACxC,OAAO,CAACyE,OAAO,KAAK3B,SAAS,EAAE;MAChE0B,OAAO,CAACC,OAAO,GAAG,IAAI,CAACzE,OAAO,CAACyE,OAAO;;IAGxC,KAAK,CAAC1B,sBAAsB,CAAChC,MAAM,EAAEC,OAAO,EAAEwD,OAAO,EAAEvD,QAAQ,CAAC;EAClE;;AArCFO;AAwCA;AACA,MAAakD,oBAAqB,SAAQ/D,qCAAkC;EAK1EC,YACEC,UAAsB,EACtBe,OAA0B,EAC1B5B,OAAgC;IAEhC,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACa,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACe,OAAO,GAAGA,OAAO;EACxB;EAESd,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAA2B;IAE3B,MAAMC,IAAI,GAAG,IAAI,CAACL,UAAU;IAC5B,MAAMe,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5B,uCAAgB,EACdV,IAAI,CAACC,CAAC,CAACC,EAAE,EACTF,IAAI,CAACG,cAAc,EACnB;MAAE,GAAG,IAAI,CAACrB,OAAO;MAAEuB,cAAc,EAAE,IAAI,CAACA,cAAc;MAAEP;IAAO,CAAE,EACjE,CAACgC,GAAG,EAAE2B,gBAAgB,KAAI;MACxB;MACA,IAAI3B,GAAG,IAAI,IAAI,EAAE,OAAO/B,QAAQ,CAAC+B,GAAG,CAAC;MACrC;MACA,IAAI,CAACrD,KAAK,CAACC,OAAO,CAACgC,OAAO,CAAC,EAAE,OAAOX,QAAQ,CAAC6B,SAAS,EAAE6B,gBAAgB,CAAC/C,OAAO,CAAC,IAAI,IAAI,CAAC;MAC1F;MACA,KAAK,IAAIgD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhD,OAAO,CAAC/B,MAAM,EAAE+E,CAAC,EAAE,EAAE;QACvC,IAAID,gBAAgB,CAAC/C,OAAO,CAACgD,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;UACxC,OAAO3D,QAAQ,CAAC6B,SAAS,EAAE,KAAK,CAAC;;;MAIrC;MACA,OAAO7B,QAAQ,CAAC6B,SAAS,EAAE,IAAI,CAAC;IAClC,CAAC,CACF;EACH;;AA5CFtB;AA+CA;AACA,MAAaqD,yBAA0B,SAAQlE,qCAAmC;EAKhFC,YAAYQ,EAAM,EAAEW,IAAY,EAAE/B,OAAiC;IACjE,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACA,OAAO,GAAGA,OAAO,IAAI,EAAE;IAC5B,IAAI,CAACoB,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACW,IAAI,GAAGA,IAAI;EAClB;EAESjB,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAA4B;IAE5B,MAAMG,EAAE,GAAG,IAAI,CAACA,EAAE;IAClB,MAAMW,IAAI,GAAG,IAAI,CAACA,IAAI;IAEtB,uCAAgB,EACdX,EAAE,EACFW,IAAI,EACJ;MAAE,GAAG,IAAI,CAAC/B,OAAO;MAAEuB,cAAc,EAAE,IAAI,CAACA,cAAc;MAAEP;IAAO,CAAE,EACjEC,QAAQ,CACT;EACH;;AA1BFO;AA6BA,6BAAa,EAAC2C,oBAAoB,EAAE,CAClCxD,kBAAM,CAACmE,cAAc,EACrBnE,kBAAM,CAACoE,SAAS,EAChBpE,kBAAM,CAACqE,eAAe,CACvB,CAAC;AACF,6BAAa,EAACvD,sBAAsB,EAAE,CAACd,kBAAM,CAACsE,eAAe,CAAC,CAAC;AAC/D,6BAAa,EAAC9B,oBAAoB,EAAE,CAACxC,kBAAM,CAACsE,eAAe,CAAC,CAAC;AAC7D,6BAAa,EAAC7B,oBAAoB,EAAE,CAACzC,kBAAM,CAACsE,eAAe,CAAC,CAAC;AAC7D,6BAAa,EAACjB,kBAAkB,EAAE,CAACrD,kBAAM,CAACsE,eAAe,CAAC,CAAC;AAC3D,6BAAa,EAACf,oBAAoB,EAAE,CAACvD,kBAAM,CAACsE,eAAe,CAAC,CAAC","names":["VALID_INDEX_OPTIONS","Set","isIndexDirection","x","isSingleIndexTuple","t","Array","isArray","length","makeIndexSpec","indexSpec","options","key","Map","indexSpecs","spec","set","property","value","Object","entries","IndexesOperation","operation_1","constructor","collection","executeCallback","server","session","callback","coll","s","db","collectionName","full","readPreference","exports","CreateIndexesOperation","command_1","parent","indexes","map","userIndex","name","from","flat","join","validIndexOptions","fromEntries","filter","optionName","has","serverWireVersion","cmd","createIndexes","commitQuorum","error_1","collation","undefined","executeCommandCallback","err","indexNames","index","CreateIndexOperation","EnsureIndexOperation","read_preference_1","primary","indexName","cursor","listIndexes","toArray","then","some","error","code","NamespaceNotFound","DropIndexOperation","dropIndexes","DropIndexesOperation","ListIndexesOperation","writeConcern","collectionNamespace","namespace","batchSize","command","comment","IndexExistsOperation","indexInformation","i","IndexInformationOperation","READ_OPERATION","RETRYABLE","CURSOR_CREATING","WRITE_OPERATION"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\operations\\indexes.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport type { Collection } from '../collection';\r\nimport type { Db } from '../db';\r\nimport { MongoCompatibilityError, MONGODB_ERROR_CODES, MongoError } from '../error';\r\nimport type { OneOrMore } from '../mongo_types';\r\nimport { ReadPreference } from '../read_preference';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport { type Callback, isObject, maxWireVersion, type MongoDBNamespace } from '../utils';\r\nimport {\r\n  type CollationOptions,\r\n  CommandCallbackOperation,\r\n  type CommandOperationOptions,\r\n  type OperationParent\r\n} from './command';\r\nimport { indexInformation, type IndexInformationOptions } from './common_functions';\r\nimport { AbstractCallbackOperation, Aspect, defineAspects } from './operation';\r\n\r\nconst VALID_INDEX_OPTIONS = new Set([\r\n  'background',\r\n  'unique',\r\n  'name',\r\n  'partialFilterExpression',\r\n  'sparse',\r\n  'hidden',\r\n  'expireAfterSeconds',\r\n  'storageEngine',\r\n  'collation',\r\n  'version',\r\n\r\n  // text indexes\r\n  'weights',\r\n  'default_language',\r\n  'language_override',\r\n  'textIndexVersion',\r\n\r\n  // 2d-sphere indexes\r\n  '2dsphereIndexVersion',\r\n\r\n  // 2d indexes\r\n  'bits',\r\n  'min',\r\n  'max',\r\n\r\n  // geoHaystack Indexes\r\n  'bucketSize',\r\n\r\n  // wildcard indexes\r\n  'wildcardProjection'\r\n]);\r\n\r\n/** @public */\r\nexport type IndexDirection =\r\n  | -1\r\n  | 1\r\n  | '2d'\r\n  | '2dsphere'\r\n  | 'text'\r\n  | 'geoHaystack'\r\n  | 'hashed'\r\n  | number;\r\n\r\nfunction isIndexDirection(x: unknown): x is IndexDirection {\r\n  return (\r\n    typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack'\r\n  );\r\n}\r\n/** @public */\r\nexport type IndexSpecification = OneOrMore<\r\n  | string\r\n  | [string, IndexDirection]\r\n  | { [key: string]: IndexDirection }\r\n  | Map<string, IndexDirection>\r\n>;\r\n\r\n/** @public */\r\nexport interface IndexDescription\r\n  extends Pick<\r\n    CreateIndexesOptions,\r\n    | 'background'\r\n    | 'unique'\r\n    | 'partialFilterExpression'\r\n    | 'sparse'\r\n    | 'hidden'\r\n    | 'expireAfterSeconds'\r\n    | 'storageEngine'\r\n    | 'version'\r\n    | 'weights'\r\n    | 'default_language'\r\n    | 'language_override'\r\n    | 'textIndexVersion'\r\n    | '2dsphereIndexVersion'\r\n    | 'bits'\r\n    | 'min'\r\n    | 'max'\r\n    | 'bucketSize'\r\n    | 'wildcardProjection'\r\n  > {\r\n  collation?: CollationOptions;\r\n  name?: string;\r\n  key: { [key: string]: IndexDirection } | Map<string, IndexDirection>;\r\n}\r\n\r\n/** @public */\r\nexport interface CreateIndexesOptions extends Omit<CommandOperationOptions, 'writeConcern'> {\r\n  /** Creates the index in the background, yielding whenever possible. */\r\n  background?: boolean;\r\n  /** Creates an unique index. */\r\n  unique?: boolean;\r\n  /** Override the autogenerated index name (useful if the resulting name is larger than 128 bytes) */\r\n  name?: string;\r\n  /** Creates a partial index based on the given filter object (MongoDB 3.2 or higher) */\r\n  partialFilterExpression?: Document;\r\n  /** Creates a sparse index. */\r\n  sparse?: boolean;\r\n  /** Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher) */\r\n  expireAfterSeconds?: number;\r\n  /** Allows users to configure the storage engine on a per-index basis when creating an index. (MongoDB 3.0 or higher) */\r\n  storageEngine?: Document;\r\n  /** (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes. */\r\n  commitQuorum?: number | string;\r\n  /** Specifies the index version number, either 0 or 1. */\r\n  version?: number;\r\n  // text indexes\r\n  weights?: Document;\r\n  default_language?: string;\r\n  language_override?: string;\r\n  textIndexVersion?: number;\r\n  // 2d-sphere indexes\r\n  '2dsphereIndexVersion'?: number;\r\n  // 2d indexes\r\n  bits?: number;\r\n  /** For geospatial indexes set the lower bound for the co-ordinates. */\r\n  min?: number;\r\n  /** For geospatial indexes set the high bound for the co-ordinates. */\r\n  max?: number;\r\n  // geoHaystack Indexes\r\n  bucketSize?: number;\r\n  // wildcard indexes\r\n  wildcardProjection?: Document;\r\n  /** Specifies that the index should exist on the target collection but should not be used by the query planner when executing operations. (MongoDB 4.4 or higher) */\r\n  hidden?: boolean;\r\n}\r\n\r\nfunction isSingleIndexTuple(t: unknown): t is [string, IndexDirection] {\r\n  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);\r\n}\r\n\r\nfunction makeIndexSpec(\r\n  indexSpec: IndexSpecification,\r\n  options?: CreateIndexesOptions\r\n): IndexDescription {\r\n  const key: Map<string, IndexDirection> = new Map();\r\n\r\n  const indexSpecs =\r\n    !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;\r\n\r\n  // Iterate through array and handle different types\r\n  for (const spec of indexSpecs) {\r\n    if (typeof spec === 'string') {\r\n      key.set(spec, 1);\r\n    } else if (Array.isArray(spec)) {\r\n      key.set(spec[0], spec[1] ?? 1);\r\n    } else if (spec instanceof Map) {\r\n      for (const [property, value] of spec) {\r\n        key.set(property, value);\r\n      }\r\n    } else if (isObject(spec)) {\r\n      for (const [property, value] of Object.entries(spec)) {\r\n        key.set(property, value);\r\n      }\r\n    }\r\n  }\r\n\r\n  return { ...options, key };\r\n}\r\n\r\n/** @internal */\r\nexport class IndexesOperation extends AbstractCallbackOperation<Document[]> {\r\n  override options: IndexInformationOptions;\r\n  collection: Collection;\r\n\r\n  constructor(collection: Collection, options: IndexInformationOptions) {\r\n    super(options);\r\n    this.options = options;\r\n    this.collection = collection;\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<Document[]>\r\n  ): void {\r\n    const coll = this.collection;\r\n    const options = this.options;\r\n\r\n    indexInformation(\r\n      coll.s.db,\r\n      coll.collectionName,\r\n      { full: true, ...options, readPreference: this.readPreference, session },\r\n      callback\r\n    );\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class CreateIndexesOperation<\r\n  T extends string | string[] = string[]\r\n> extends CommandCallbackOperation<T> {\r\n  override options: CreateIndexesOptions;\r\n  collectionName: string;\r\n  indexes: ReadonlyArray<Omit<IndexDescription, 'key'> & { key: Map<string, IndexDirection> }>;\r\n\r\n  constructor(\r\n    parent: OperationParent,\r\n    collectionName: string,\r\n    indexes: IndexDescription[],\r\n    options?: CreateIndexesOptions\r\n  ) {\r\n    super(parent, options);\r\n\r\n    this.options = options ?? {};\r\n    this.collectionName = collectionName;\r\n    this.indexes = indexes.map(userIndex => {\r\n      // Ensure the key is a Map to preserve index key ordering\r\n      const key =\r\n        userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));\r\n      const name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join('_');\r\n      const validIndexOptions = Object.fromEntries(\r\n        Object.entries({ ...userIndex }).filter(([optionName]) =>\r\n          VALID_INDEX_OPTIONS.has(optionName)\r\n        )\r\n      );\r\n      return {\r\n        ...validIndexOptions,\r\n        name,\r\n        key\r\n      };\r\n    });\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<T>\r\n  ): void {\r\n    const options = this.options;\r\n    const indexes = this.indexes;\r\n\r\n    const serverWireVersion = maxWireVersion(server);\r\n\r\n    const cmd: Document = { createIndexes: this.collectionName, indexes };\r\n\r\n    if (options.commitQuorum != null) {\r\n      if (serverWireVersion < 9) {\r\n        callback(\r\n          new MongoCompatibilityError(\r\n            'Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'\r\n          )\r\n        );\r\n        return;\r\n      }\r\n      cmd.commitQuorum = options.commitQuorum;\r\n    }\r\n\r\n    // collation is set on each index, it should not be defined at the root\r\n    this.options.collation = undefined;\r\n\r\n    super.executeCommandCallback(server, session, cmd, err => {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const indexNames = indexes.map(index => index.name || '');\r\n      callback(undefined, indexNames as T);\r\n    });\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class CreateIndexOperation extends CreateIndexesOperation<string> {\r\n  constructor(\r\n    parent: OperationParent,\r\n    collectionName: string,\r\n    indexSpec: IndexSpecification,\r\n    options?: CreateIndexesOptions\r\n  ) {\r\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\r\n  }\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<string>\r\n  ): void {\r\n    super.executeCallback(server, session, (err, indexNames) => {\r\n      if (err || !indexNames) return callback(err);\r\n      return callback(undefined, indexNames[0]);\r\n    });\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class EnsureIndexOperation extends CreateIndexOperation {\r\n  db: Db;\r\n\r\n  constructor(\r\n    db: Db,\r\n    collectionName: string,\r\n    indexSpec: IndexSpecification,\r\n    options?: CreateIndexesOptions\r\n  ) {\r\n    super(db, collectionName, indexSpec, options);\r\n\r\n    this.readPreference = ReadPreference.primary;\r\n    this.db = db;\r\n    this.collectionName = collectionName;\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback\r\n  ): void {\r\n    const indexName = this.indexes[0].name;\r\n    const cursor = this.db.collection(this.collectionName).listIndexes({ session });\r\n    cursor.toArray().then(\r\n      indexes => {\r\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\r\n        if (indexes.some(index => index.name === indexName)) {\r\n          callback(undefined, indexName);\r\n          return;\r\n        }\r\n        super.executeCallback(server, session, callback);\r\n      },\r\n      error => {\r\n        if (error instanceof MongoError && error.code === MONGODB_ERROR_CODES.NamespaceNotFound) {\r\n          // ignore \"NamespaceNotFound\" errors\r\n          return super.executeCallback(server, session, callback);\r\n        }\r\n        return callback(error);\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport type DropIndexesOptions = CommandOperationOptions;\r\n\r\n/** @internal */\r\nexport class DropIndexOperation extends CommandCallbackOperation<Document> {\r\n  override options: DropIndexesOptions;\r\n  collection: Collection;\r\n  indexName: string;\r\n\r\n  constructor(collection: Collection, indexName: string, options?: DropIndexesOptions) {\r\n    super(collection, options);\r\n\r\n    this.options = options ?? {};\r\n    this.collection = collection;\r\n    this.indexName = indexName;\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<Document>\r\n  ): void {\r\n    const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };\r\n    super.executeCommandCallback(server, session, cmd, callback);\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class DropIndexesOperation extends DropIndexOperation {\r\n  constructor(collection: Collection, options: DropIndexesOptions) {\r\n    super(collection, '*', options);\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback\r\n  ): void {\r\n    super.executeCallback(server, session, err => {\r\n      if (err) return callback(err, false);\r\n      callback(undefined, true);\r\n    });\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport interface ListIndexesOptions extends Omit<CommandOperationOptions, 'writeConcern'> {\r\n  /** The batchSize for the returned command cursor or if pre 2.8 the systems batch collection */\r\n  batchSize?: number;\r\n}\r\n\r\n/** @internal */\r\nexport class ListIndexesOperation extends CommandCallbackOperation<Document> {\r\n  /**\r\n   * @remarks WriteConcern can still be present on the options because\r\n   * we inherit options from the client/db/collection.  The\r\n   * key must be present on the options in order to delete it.\r\n   * This allows typescript to delete the key but will\r\n   * not allow a writeConcern to be assigned as a property on options.\r\n   */\r\n  override options: ListIndexesOptions & { writeConcern?: never };\r\n  collectionNamespace: MongoDBNamespace;\r\n\r\n  constructor(collection: Collection, options?: ListIndexesOptions) {\r\n    super(collection, options);\r\n\r\n    this.options = { ...options };\r\n    delete this.options.writeConcern;\r\n    this.collectionNamespace = collection.s.namespace;\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<Document>\r\n  ): void {\r\n    const serverWireVersion = maxWireVersion(server);\r\n\r\n    const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};\r\n\r\n    const command: Document = { listIndexes: this.collectionNamespace.collection, cursor };\r\n\r\n    // we check for undefined specifically here to allow falsy values\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\r\n      command.comment = this.options.comment;\r\n    }\r\n\r\n    super.executeCommandCallback(server, session, command, callback);\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class IndexExistsOperation extends AbstractCallbackOperation<boolean> {\r\n  override options: IndexInformationOptions;\r\n  collection: Collection;\r\n  indexes: string | string[];\r\n\r\n  constructor(\r\n    collection: Collection,\r\n    indexes: string | string[],\r\n    options: IndexInformationOptions\r\n  ) {\r\n    super(options);\r\n    this.options = options;\r\n    this.collection = collection;\r\n    this.indexes = indexes;\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<boolean>\r\n  ): void {\r\n    const coll = this.collection;\r\n    const indexes = this.indexes;\r\n\r\n    indexInformation(\r\n      coll.s.db,\r\n      coll.collectionName,\r\n      { ...this.options, readPreference: this.readPreference, session },\r\n      (err, indexInformation) => {\r\n        // If we have an error return\r\n        if (err != null) return callback(err);\r\n        // Let's check for the index names\r\n        if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null);\r\n        // Check in list of indexes\r\n        for (let i = 0; i < indexes.length; i++) {\r\n          if (indexInformation[indexes[i]] == null) {\r\n            return callback(undefined, false);\r\n          }\r\n        }\r\n\r\n        // All keys found return true\r\n        return callback(undefined, true);\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class IndexInformationOperation extends AbstractCallbackOperation<Document> {\r\n  override options: IndexInformationOptions;\r\n  db: Db;\r\n  name: string;\r\n\r\n  constructor(db: Db, name: string, options?: IndexInformationOptions) {\r\n    super(options);\r\n    this.options = options ?? {};\r\n    this.db = db;\r\n    this.name = name;\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<Document>\r\n  ): void {\r\n    const db = this.db;\r\n    const name = this.name;\r\n\r\n    indexInformation(\r\n      db,\r\n      name,\r\n      { ...this.options, readPreference: this.readPreference, session },\r\n      callback\r\n    );\r\n  }\r\n}\r\n\r\ndefineAspects(ListIndexesOperation, [\r\n  Aspect.READ_OPERATION,\r\n  Aspect.RETRYABLE,\r\n  Aspect.CURSOR_CREATING\r\n]);\r\ndefineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION]);\r\ndefineAspects(CreateIndexOperation, [Aspect.WRITE_OPERATION]);\r\ndefineAspects(EnsureIndexOperation, [Aspect.WRITE_OPERATION]);\r\ndefineAspects(DropIndexOperation, [Aspect.WRITE_OPERATION]);\r\ndefineAspects(DropIndexesOperation, [Aspect.WRITE_OPERATION]);\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}