{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallbackLockCache = void 0;\nconst error_1 = require(\"../../../error\");\nconst cache_1 = require(\"./cache\");\n/** Error message for when request callback is missing. */\nconst REQUEST_CALLBACK_REQUIRED_ERROR = 'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.';\n/* Counter for function \"hashes\".*/\nlet FN_HASH_COUNTER = 0;\n/* No function present function */\nconst NO_FUNCTION = async () => ({\n  accessToken: 'test'\n});\n/* The map of function hashes */\nconst FN_HASHES = new WeakMap();\n/* Put the no function hash in the map. */\nFN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);\n/**\r\n * A cache of request and refresh callbacks per server/user.\r\n */\nclass CallbackLockCache extends cache_1.Cache {\n  /**\r\n   * Get the callbacks for the connection and credentials. If an entry does not\r\n   * exist a new one will get set.\r\n   */\n  getEntry(connection, credentials) {\n    const requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\n    const refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\n    if (!requestCallback) {\n      throw new error_1.MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);\n    }\n    const callbackHash = hashFunctions(requestCallback, refreshCallback);\n    const key = this.cacheKey(connection.address, credentials.username, callbackHash);\n    const entry = this.entries.get(key);\n    if (entry) {\n      return entry;\n    }\n    return this.addEntry(key, callbackHash, requestCallback, refreshCallback);\n  }\n  /**\r\n   * Set locked callbacks on for connection and credentials.\r\n   */\n  addEntry(key, callbackHash, requestCallback, refreshCallback) {\n    const entry = {\n      requestCallback: withLock(requestCallback),\n      refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,\n      callbackHash: callbackHash\n    };\n    this.entries.set(key, entry);\n    return entry;\n  }\n  /**\r\n   * Create a cache key from the address and username.\r\n   */\n  cacheKey(address, username, callbackHash) {\n    return this.hashedCacheKey(address, username, callbackHash);\n  }\n}\nexports.CallbackLockCache = CallbackLockCache;\n/**\r\n * Ensure the callback is only executed one at a time.\r\n */\nfunction withLock(callback) {\n  let lock = Promise.resolve();\n  return async (info, context) => {\n    await lock;\n    lock = lock.then(() => callback(info, context));\n    return lock;\n  };\n}\n/**\r\n * Get the hash string for the request and refresh functions.\r\n */\nfunction hashFunctions(requestFn, refreshFn) {\n  let requestHash = FN_HASHES.get(requestFn);\n  let refreshHash = FN_HASHES.get(refreshFn ?? NO_FUNCTION);\n  if (requestHash == null) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    requestHash = FN_HASH_COUNTER;\n    FN_HASHES.set(requestFn, FN_HASH_COUNTER);\n  }\n  if (refreshHash == null && refreshFn) {\n    // Create a new one for the function and put it in the map.\n    FN_HASH_COUNTER++;\n    refreshHash = FN_HASH_COUNTER;\n    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);\n  }\n  return `${requestHash}-${refreshHash}`;\n}","map":{"version":3,"mappings":"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","names":["REQUEST_CALLBACK_REQUIRED_ERROR","FN_HASH_COUNTER","NO_FUNCTION","accessToken","FN_HASHES","WeakMap","set","CallbackLockCache","cache_1","getEntry","connection","credentials","requestCallback","mechanismProperties","REQUEST_TOKEN_CALLBACK","refreshCallback","REFRESH_TOKEN_CALLBACK","error_1","callbackHash","hashFunctions","key","cacheKey","address","username","entry","entries","get","addEntry","withLock","undefined","hashedCacheKey","exports","callback","lock","Promise","resolve","info","context","then","requestFn","refreshFn","requestHash","refreshHash"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_oidc\\callback_lock_cache.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from '../../../error';\r\nimport type { Connection } from '../../connection';\r\nimport type { MongoCredentials } from '../mongo_credentials';\r\nimport type {\r\n  IdPServerInfo,\r\n  IdPServerResponse,\r\n  OIDCCallbackContext,\r\n  OIDCRefreshFunction,\r\n  OIDCRequestFunction\r\n} from '../mongodb_oidc';\r\nimport { Cache } from './cache';\r\n\r\n/** Error message for when request callback is missing. */\r\nconst REQUEST_CALLBACK_REQUIRED_ERROR =\r\n  'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.';\r\n/* Counter for function \"hashes\".*/\r\nlet FN_HASH_COUNTER = 0;\r\n/* No function present function */\r\nconst NO_FUNCTION: OIDCRequestFunction = async () => ({ accessToken: 'test' });\r\n/* The map of function hashes */\r\nconst FN_HASHES = new WeakMap<OIDCRequestFunction | OIDCRefreshFunction, number>();\r\n/* Put the no function hash in the map. */\r\nFN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);\r\n\r\n/**\r\n * An entry of callbacks in the cache.\r\n */\r\ninterface CallbacksEntry {\r\n  requestCallback: OIDCRequestFunction;\r\n  refreshCallback?: OIDCRefreshFunction;\r\n  callbackHash: string;\r\n}\r\n\r\n/**\r\n * A cache of request and refresh callbacks per server/user.\r\n */\r\nexport class CallbackLockCache extends Cache<CallbacksEntry> {\r\n  /**\r\n   * Get the callbacks for the connection and credentials. If an entry does not\r\n   * exist a new one will get set.\r\n   */\r\n  getEntry(connection: Connection, credentials: MongoCredentials): CallbacksEntry {\r\n    const requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;\r\n    const refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;\r\n    if (!requestCallback) {\r\n      throw new MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);\r\n    }\r\n    const callbackHash = hashFunctions(requestCallback, refreshCallback);\r\n    const key = this.cacheKey(connection.address, credentials.username, callbackHash);\r\n    const entry = this.entries.get(key);\r\n    if (entry) {\r\n      return entry;\r\n    }\r\n    return this.addEntry(key, callbackHash, requestCallback, refreshCallback);\r\n  }\r\n\r\n  /**\r\n   * Set locked callbacks on for connection and credentials.\r\n   */\r\n  private addEntry(\r\n    key: string,\r\n    callbackHash: string,\r\n    requestCallback: OIDCRequestFunction,\r\n    refreshCallback?: OIDCRefreshFunction\r\n  ): CallbacksEntry {\r\n    const entry = {\r\n      requestCallback: withLock(requestCallback),\r\n      refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,\r\n      callbackHash: callbackHash\r\n    };\r\n    this.entries.set(key, entry);\r\n    return entry;\r\n  }\r\n\r\n  /**\r\n   * Create a cache key from the address and username.\r\n   */\r\n  cacheKey(address: string, username: string, callbackHash: string): string {\r\n    return this.hashedCacheKey(address, username, callbackHash);\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure the callback is only executed one at a time.\r\n */\r\nfunction withLock(callback: OIDCRequestFunction | OIDCRefreshFunction) {\r\n  let lock: Promise<any> = Promise.resolve();\r\n  return async (info: IdPServerInfo, context: OIDCCallbackContext): Promise<IdPServerResponse> => {\r\n    await lock;\r\n    lock = lock.then(() => callback(info, context));\r\n    return lock;\r\n  };\r\n}\r\n\r\n/**\r\n * Get the hash string for the request and refresh functions.\r\n */\r\nfunction hashFunctions(requestFn: OIDCRequestFunction, refreshFn?: OIDCRefreshFunction): string {\r\n  let requestHash = FN_HASHES.get(requestFn);\r\n  let refreshHash = FN_HASHES.get(refreshFn ?? NO_FUNCTION);\r\n  if (requestHash == null) {\r\n    // Create a new one for the function and put it in the map.\r\n    FN_HASH_COUNTER++;\r\n    requestHash = FN_HASH_COUNTER;\r\n    FN_HASHES.set(requestFn, FN_HASH_COUNTER);\r\n  }\r\n  if (refreshHash == null && refreshFn) {\r\n    // Create a new one for the function and put it in the map.\r\n    FN_HASH_COUNTER++;\r\n    refreshHash = FN_HASH_COUNTER;\r\n    FN_HASHES.set(refreshFn, FN_HASH_COUNTER);\r\n  }\r\n  return `${requestHash}-${refreshHash}`;\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}