{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallbackWorkflow = void 0;\nconst bson_1 = require(\"bson\");\nconst error_1 = require(\"../../../error\");\nconst utils_1 = require(\"../../../utils\");\nconst providers_1 = require(\"../providers\");\nconst callback_lock_cache_1 = require(\"./callback_lock_cache\");\nconst token_entry_cache_1 = require(\"./token_entry_cache\");\n/** The current version of OIDC implementation. */\nconst OIDC_VERSION = 0;\n/** 5 minutes in seconds */\nconst TIMEOUT_S = 300;\n/** Properties allowed on results of callbacks. */\nconst RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];\n/** Error message when the callback result is invalid. */\nconst CALLBACK_RESULT_ERROR = 'User provided OIDC callbacks must return a valid object with an accessToken.';\n/**\r\n * OIDC implementation of a callback based workflow.\r\n * @internal\r\n */\nclass CallbackWorkflow {\n  /**\r\n   * Instantiate the workflow\r\n   */\n  constructor() {\n    this.cache = new token_entry_cache_1.TokenEntryCache();\n    this.callbackCache = new callback_lock_cache_1.CallbackLockCache();\n  }\n  /**\r\n   * Get the document to add for speculative authentication. This also needs\r\n   * to add a db field from the credentials source.\r\n   */\n  async speculativeAuth(credentials) {\n    const document = startCommandDocument(credentials);\n    document.db = credentials.source;\n    return {\n      speculativeAuthenticate: document\n    };\n  }\n  /**\r\n   * Execute the OIDC callback workflow.\r\n   */\n  async execute(connection, credentials, reauthenticating, response) {\n    // Get the callbacks with locks from the callback lock cache.\n    const {\n      requestCallback,\n      refreshCallback,\n      callbackHash\n    } = this.callbackCache.getEntry(connection, credentials);\n    // Look for an existing entry in the cache.\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n    let result;\n    if (entry) {\n      // Reauthentication cannot use a token from the cache since the server has\n      // stated it is invalid by the request for reauthentication.\n      if (entry.isValid() && !reauthenticating) {\n        // Presence of a valid cache entry means we can skip to the finishing step.\n        result = await this.finishAuthentication(connection, credentials, entry.tokenResult, response?.speculativeAuthenticate?.conversationId);\n      } else {\n        // Presence of an expired cache entry means we must fetch a new one and\n        // then execute the final step.\n        const tokenResult = await this.fetchAccessToken(connection, credentials, entry.serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback);\n        try {\n          result = await this.finishAuthentication(connection, credentials, tokenResult, reauthenticating ? undefined : response?.speculativeAuthenticate?.conversationId);\n        } catch (error) {\n          // If we are reauthenticating and this errors with reauthentication\n          // required, we need to do the entire process over again and clear\n          // the cache entry.\n          if (reauthenticating && error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {\n            this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n            result = await this.execute(connection, credentials, reauthenticating);\n          } else {\n            throw error;\n          }\n        }\n      }\n    } else {\n      // No entry in the cache requires us to do all authentication steps\n      // from start to finish, including getting a fresh token for the cache.\n      const startDocument = await this.startAuthentication(connection, credentials, reauthenticating, response);\n      const conversationId = startDocument.conversationId;\n      const serverResult = bson_1.BSON.deserialize(startDocument.payload.buffer);\n      const tokenResult = await this.fetchAccessToken(connection, credentials, serverResult, reauthenticating, callbackHash, requestCallback, refreshCallback);\n      result = await this.finishAuthentication(connection, credentials, tokenResult, conversationId);\n    }\n    return result;\n  }\n  /**\r\n   * Starts the callback authentication process. If there is a speculative\r\n   * authentication document from the initial handshake, then we will use that\r\n   * value to get the issuer, otherwise we will send the saslStart command.\r\n   */\n  async startAuthentication(connection, credentials, reauthenticating, response) {\n    let result;\n    if (!reauthenticating && response?.speculativeAuthenticate) {\n      result = response.speculativeAuthenticate;\n    } else {\n      result = await connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);\n    }\n    return result;\n  }\n  /**\r\n   * Finishes the callback authentication process.\r\n   */\n  async finishAuthentication(connection, credentials, tokenResult, conversationId) {\n    const result = await connection.commandAsync((0, utils_1.ns)(credentials.source), finishCommandDocument(tokenResult.accessToken, conversationId), undefined);\n    return result;\n  }\n  /**\r\n   * Fetches an access token using either the request or refresh callbacks and\r\n   * puts it in the cache.\r\n   */\n  async fetchAccessToken(connection, credentials, serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback) {\n    // Get the token from the cache.\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\n    let result;\n    const context = {\n      timeoutSeconds: TIMEOUT_S,\n      version: OIDC_VERSION\n    };\n    // Check if there's a token in the cache.\n    if (entry) {\n      // If the cache entry is valid, return the token result.\n      if (entry.isValid() && !reauthenticating) {\n        return entry.tokenResult;\n      }\n      // If the cache entry is not valid, remove it from the cache and first attempt\n      // to use the refresh callback to get a new token. If no refresh callback\n      // exists, then fallback to the request callback.\n      if (refreshCallback) {\n        context.refreshToken = entry.tokenResult.refreshToken;\n        result = await refreshCallback(serverInfo, context);\n      } else {\n        result = await requestCallback(serverInfo, context);\n      }\n    } else {\n      // With no token in the cache we use the request callback.\n      result = await requestCallback(serverInfo, context);\n    }\n    // Validate that the result returned by the callback is acceptable. If it is not\n    // we must clear the token result from the cache.\n    if (isCallbackResultInvalid(result)) {\n      this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\n      throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);\n    }\n    // Cleanup the cache.\n    this.cache.deleteExpiredEntries();\n    // Put the new entry into the cache.\n    this.cache.addEntry(connection.address, credentials.username || '', callbackHash, result, serverInfo);\n    return result;\n  }\n}\nexports.CallbackWorkflow = CallbackWorkflow;\n/**\r\n * Generate the finishing command document for authentication. Will be a\r\n * saslStart or saslContinue depending on the presence of a conversation id.\r\n */\nfunction finishCommandDocument(token, conversationId) {\n  if (conversationId != null && typeof conversationId === 'number') {\n    return {\n      saslContinue: 1,\n      conversationId: conversationId,\n      payload: new bson_1.Binary(bson_1.BSON.serialize({\n        jwt: token\n      }))\n    };\n  }\n  // saslContinue requires a conversationId in the command to be valid so in this\n  // case the server allows \"step two\" to actually be a saslStart with the token\n  // as the jwt since the use of the cached value has no correlating conversating\n  // on the particular connection.\n  return {\n    saslStart: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize({\n      jwt: token\n    }))\n  };\n}\n/**\r\n * Determines if a result returned from a request or refresh callback\r\n * function is invalid. This means the result is nullish, doesn't contain\r\n * the accessToken required field, and does not contain extra fields.\r\n */\nfunction isCallbackResultInvalid(tokenResult) {\n  if (tokenResult == null || typeof tokenResult !== 'object') return true;\n  if (!('accessToken' in tokenResult)) return true;\n  return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));\n}\n/**\r\n * Generate the saslStart command document.\r\n */\nfunction startCommandDocument(credentials) {\n  const payload = {};\n  if (credentials.username) {\n    payload.n = credentials.username;\n  }\n  return {\n    saslStart: 1,\n    autoAuthorize: 1,\n    mechanism: providers_1.AuthMechanism.MONGODB_OIDC,\n    payload: new bson_1.Binary(bson_1.BSON.serialize(payload))\n  };\n}","map":{"version":3,"mappings":"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","names":["OIDC_VERSION","TIMEOUT_S","RESULT_PROPERTIES","CALLBACK_RESULT_ERROR","CallbackWorkflow","constructor","cache","token_entry_cache_1","callbackCache","callback_lock_cache_1","speculativeAuth","credentials","document","startCommandDocument","db","source","speculativeAuthenticate","execute","connection","reauthenticating","response","requestCallback","refreshCallback","callbackHash","getEntry","entry","address","username","result","isValid","finishAuthentication","tokenResult","conversationId","fetchAccessToken","serverInfo","undefined","error","error_1","code","Reauthenticate","deleteEntry","startDocument","startAuthentication","serverResult","bson_1","deserialize","payload","buffer","commandAsync","finishCommandDocument","accessToken","context","timeoutSeconds","version","refreshToken","isCallbackResultInvalid","deleteExpiredEntries","addEntry","exports","token","saslContinue","serialize","jwt","saslStart","mechanism","providers_1","MONGODB_OIDC","Object","getOwnPropertyNames","every","prop","includes","n","autoAuthorize"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_oidc\\callback_workflow.ts"],"sourcesContent":["import { Binary, BSON, type Document } from 'bson';\r\n\r\nimport { MONGODB_ERROR_CODES, MongoError, MongoMissingCredentialsError } from '../../../error';\r\nimport { ns } from '../../../utils';\r\nimport type { Connection } from '../../connection';\r\nimport type { MongoCredentials } from '../mongo_credentials';\r\nimport type {\r\n  IdPServerInfo,\r\n  IdPServerResponse,\r\n  OIDCCallbackContext,\r\n  OIDCRefreshFunction,\r\n  OIDCRequestFunction,\r\n  Workflow\r\n} from '../mongodb_oidc';\r\nimport { AuthMechanism } from '../providers';\r\nimport { CallbackLockCache } from './callback_lock_cache';\r\nimport { TokenEntryCache } from './token_entry_cache';\r\n\r\n/** The current version of OIDC implementation. */\r\nconst OIDC_VERSION = 0;\r\n\r\n/** 5 minutes in seconds */\r\nconst TIMEOUT_S = 300;\r\n\r\n/** Properties allowed on results of callbacks. */\r\nconst RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];\r\n\r\n/** Error message when the callback result is invalid. */\r\nconst CALLBACK_RESULT_ERROR =\r\n  'User provided OIDC callbacks must return a valid object with an accessToken.';\r\n\r\n/**\r\n * OIDC implementation of a callback based workflow.\r\n * @internal\r\n */\r\nexport class CallbackWorkflow implements Workflow {\r\n  cache: TokenEntryCache;\r\n  callbackCache: CallbackLockCache;\r\n\r\n  /**\r\n   * Instantiate the workflow\r\n   */\r\n  constructor() {\r\n    this.cache = new TokenEntryCache();\r\n    this.callbackCache = new CallbackLockCache();\r\n  }\r\n\r\n  /**\r\n   * Get the document to add for speculative authentication. This also needs\r\n   * to add a db field from the credentials source.\r\n   */\r\n  async speculativeAuth(credentials: MongoCredentials): Promise<Document> {\r\n    const document = startCommandDocument(credentials);\r\n    document.db = credentials.source;\r\n    return { speculativeAuthenticate: document };\r\n  }\r\n\r\n  /**\r\n   * Execute the OIDC callback workflow.\r\n   */\r\n  async execute(\r\n    connection: Connection,\r\n    credentials: MongoCredentials,\r\n    reauthenticating: boolean,\r\n    response?: Document\r\n  ): Promise<Document> {\r\n    // Get the callbacks with locks from the callback lock cache.\r\n    const { requestCallback, refreshCallback, callbackHash } = this.callbackCache.getEntry(\r\n      connection,\r\n      credentials\r\n    );\r\n    // Look for an existing entry in the cache.\r\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\r\n    let result;\r\n    if (entry) {\r\n      // Reauthentication cannot use a token from the cache since the server has\r\n      // stated it is invalid by the request for reauthentication.\r\n      if (entry.isValid() && !reauthenticating) {\r\n        // Presence of a valid cache entry means we can skip to the finishing step.\r\n        result = await this.finishAuthentication(\r\n          connection,\r\n          credentials,\r\n          entry.tokenResult,\r\n          response?.speculativeAuthenticate?.conversationId\r\n        );\r\n      } else {\r\n        // Presence of an expired cache entry means we must fetch a new one and\r\n        // then execute the final step.\r\n        const tokenResult = await this.fetchAccessToken(\r\n          connection,\r\n          credentials,\r\n          entry.serverInfo,\r\n          reauthenticating,\r\n          callbackHash,\r\n          requestCallback,\r\n          refreshCallback\r\n        );\r\n        try {\r\n          result = await this.finishAuthentication(\r\n            connection,\r\n            credentials,\r\n            tokenResult,\r\n            reauthenticating ? undefined : response?.speculativeAuthenticate?.conversationId\r\n          );\r\n        } catch (error) {\r\n          // If we are reauthenticating and this errors with reauthentication\r\n          // required, we need to do the entire process over again and clear\r\n          // the cache entry.\r\n          if (\r\n            reauthenticating &&\r\n            error instanceof MongoError &&\r\n            error.code === MONGODB_ERROR_CODES.Reauthenticate\r\n          ) {\r\n            this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\r\n            result = await this.execute(connection, credentials, reauthenticating);\r\n          } else {\r\n            throw error;\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // No entry in the cache requires us to do all authentication steps\r\n      // from start to finish, including getting a fresh token for the cache.\r\n      const startDocument = await this.startAuthentication(\r\n        connection,\r\n        credentials,\r\n        reauthenticating,\r\n        response\r\n      );\r\n      const conversationId = startDocument.conversationId;\r\n      const serverResult = BSON.deserialize(startDocument.payload.buffer) as IdPServerInfo;\r\n      const tokenResult = await this.fetchAccessToken(\r\n        connection,\r\n        credentials,\r\n        serverResult,\r\n        reauthenticating,\r\n        callbackHash,\r\n        requestCallback,\r\n        refreshCallback\r\n      );\r\n      result = await this.finishAuthentication(\r\n        connection,\r\n        credentials,\r\n        tokenResult,\r\n        conversationId\r\n      );\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Starts the callback authentication process. If there is a speculative\r\n   * authentication document from the initial handshake, then we will use that\r\n   * value to get the issuer, otherwise we will send the saslStart command.\r\n   */\r\n  private async startAuthentication(\r\n    connection: Connection,\r\n    credentials: MongoCredentials,\r\n    reauthenticating: boolean,\r\n    response?: Document\r\n  ): Promise<Document> {\r\n    let result;\r\n    if (!reauthenticating && response?.speculativeAuthenticate) {\r\n      result = response.speculativeAuthenticate;\r\n    } else {\r\n      result = await connection.commandAsync(\r\n        ns(credentials.source),\r\n        startCommandDocument(credentials),\r\n        undefined\r\n      );\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Finishes the callback authentication process.\r\n   */\r\n  private async finishAuthentication(\r\n    connection: Connection,\r\n    credentials: MongoCredentials,\r\n    tokenResult: IdPServerResponse,\r\n    conversationId?: number\r\n  ): Promise<Document> {\r\n    const result = await connection.commandAsync(\r\n      ns(credentials.source),\r\n      finishCommandDocument(tokenResult.accessToken, conversationId),\r\n      undefined\r\n    );\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Fetches an access token using either the request or refresh callbacks and\r\n   * puts it in the cache.\r\n   */\r\n  private async fetchAccessToken(\r\n    connection: Connection,\r\n    credentials: MongoCredentials,\r\n    serverInfo: IdPServerInfo,\r\n    reauthenticating: boolean,\r\n    callbackHash: string,\r\n    requestCallback: OIDCRequestFunction,\r\n    refreshCallback?: OIDCRefreshFunction\r\n  ): Promise<IdPServerResponse> {\r\n    // Get the token from the cache.\r\n    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);\r\n    let result;\r\n    const context: OIDCCallbackContext = { timeoutSeconds: TIMEOUT_S, version: OIDC_VERSION };\r\n    // Check if there's a token in the cache.\r\n    if (entry) {\r\n      // If the cache entry is valid, return the token result.\r\n      if (entry.isValid() && !reauthenticating) {\r\n        return entry.tokenResult;\r\n      }\r\n      // If the cache entry is not valid, remove it from the cache and first attempt\r\n      // to use the refresh callback to get a new token. If no refresh callback\r\n      // exists, then fallback to the request callback.\r\n      if (refreshCallback) {\r\n        context.refreshToken = entry.tokenResult.refreshToken;\r\n        result = await refreshCallback(serverInfo, context);\r\n      } else {\r\n        result = await requestCallback(serverInfo, context);\r\n      }\r\n    } else {\r\n      // With no token in the cache we use the request callback.\r\n      result = await requestCallback(serverInfo, context);\r\n    }\r\n    // Validate that the result returned by the callback is acceptable. If it is not\r\n    // we must clear the token result from the cache.\r\n    if (isCallbackResultInvalid(result)) {\r\n      this.cache.deleteEntry(connection.address, credentials.username, callbackHash);\r\n      throw new MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);\r\n    }\r\n    // Cleanup the cache.\r\n    this.cache.deleteExpiredEntries();\r\n    // Put the new entry into the cache.\r\n    this.cache.addEntry(\r\n      connection.address,\r\n      credentials.username || '',\r\n      callbackHash,\r\n      result,\r\n      serverInfo\r\n    );\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate the finishing command document for authentication. Will be a\r\n * saslStart or saslContinue depending on the presence of a conversation id.\r\n */\r\nfunction finishCommandDocument(token: string, conversationId?: number): Document {\r\n  if (conversationId != null && typeof conversationId === 'number') {\r\n    return {\r\n      saslContinue: 1,\r\n      conversationId: conversationId,\r\n      payload: new Binary(BSON.serialize({ jwt: token }))\r\n    };\r\n  }\r\n  // saslContinue requires a conversationId in the command to be valid so in this\r\n  // case the server allows \"step two\" to actually be a saslStart with the token\r\n  // as the jwt since the use of the cached value has no correlating conversating\r\n  // on the particular connection.\r\n  return {\r\n    saslStart: 1,\r\n    mechanism: AuthMechanism.MONGODB_OIDC,\r\n    payload: new Binary(BSON.serialize({ jwt: token }))\r\n  };\r\n}\r\n\r\n/**\r\n * Determines if a result returned from a request or refresh callback\r\n * function is invalid. This means the result is nullish, doesn't contain\r\n * the accessToken required field, and does not contain extra fields.\r\n */\r\nfunction isCallbackResultInvalid(tokenResult: unknown): boolean {\r\n  if (tokenResult == null || typeof tokenResult !== 'object') return true;\r\n  if (!('accessToken' in tokenResult)) return true;\r\n  return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));\r\n}\r\n\r\n/**\r\n * Generate the saslStart command document.\r\n */\r\nfunction startCommandDocument(credentials: MongoCredentials): Document {\r\n  const payload: Document = {};\r\n  if (credentials.username) {\r\n    payload.n = credentials.username;\r\n  }\r\n  return {\r\n    saslStart: 1,\r\n    autoAuthorize: 1,\r\n    mechanism: AuthMechanism.MONGODB_OIDC,\r\n    payload: new Binary(BSON.serialize(payload))\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}