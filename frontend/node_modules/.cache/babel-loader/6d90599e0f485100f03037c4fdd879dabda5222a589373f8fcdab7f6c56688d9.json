{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\nconst timers_1 = require(\"timers\");\nconst util_1 = require(\"util\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst commands_1 = require(\"./commands\");\nconst message_stream_1 = require(\"./message_stream\");\nconst stream_description_1 = require(\"./stream_description\");\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\nconst INVALID_QUEUE_SIZE = 'Connection internal queue contains more than 1 operation description';\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    super();\n    this.commandAsync = (0, util_1.promisify)((ns, cmd, options, callback) => this.command(ns, cmd, options, callback));\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)();\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n    this[kDelayedTimeoutId] = null;\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    // hook the message stream up to the passed in stream\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n  get description() {\n    return this[kDescription];\n  }\n  get hello() {\n    return this[kHello];\n  }\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n  // Set the whether the message stream is for a monitoring connection.\n  set isMonitoringConnection(value) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n  get isMonitoringConnection() {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n  get serviceId() {\n    return this.hello?.serviceId;\n  }\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n  get stream() {\n    return this[kStream];\n  }\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n  onError(error) {\n    this.cleanup(true, error);\n  }\n  onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(true, new error_1.MongoNetworkError(message));\n  }\n  onTimeout() {\n    this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(true, new error_1.MongoNetworkTimeoutError(message, {\n        beforeHandshake\n      }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      (0, timers_1.clearTimeout)(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n    const socketTimeoutMS = this[kStream].timeout ?? 0;\n    this[kStream].setTimeout(0);\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    let operationDescription = this[kQueue].get(message.responseTo);\n    if (!operationDescription && this.isMonitoringConnection) {\n      // This is how we recover when the initial hello's requestId is not\n      // the responseTo when hello responses have been skipped:\n      // First check if the map is of invalid size\n      if (this[kQueue].size > 1) {\n        this.cleanup(true, new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));\n      } else {\n        // Get the first orphaned operation description.\n        const entry = this[kQueue].entries().next();\n        if (entry.value != null) {\n          const [requestId, orphaned] = entry.value;\n          // If the orphaned operation description exists then set it.\n          operationDescription = orphaned;\n          // Remove the entry with the bad request id from the queue.\n          this[kQueue].delete(requestId);\n        }\n      }\n    }\n    if (!operationDescription) {\n      return;\n    }\n    const callback = operationDescription.cb;\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // If the operation description check above does find an orphaned\n      // description and sets the operationDescription then this line will put one\n      // back in the queue with the correct requestId and will resolve not being able\n      // to find the next one via the responseTo of the next streaming hello.\n      this[kQueue].set(message.requestId, operationDescription);\n      this[kStream].setTimeout(socketTimeoutMS);\n    }\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n      if (document.writeConcernError) {\n        callback(new error_1.MongoWriteConcernError(document.writeConcernError, document), document);\n        return;\n      }\n      if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n        callback(new error_1.MongoServerError(document));\n        return;\n      }\n    }\n    callback(undefined, message.documents[0]);\n  }\n  destroy(options, callback) {\n    if (this.closed) {\n      process.nextTick(() => callback?.());\n      return;\n    }\n    if (typeof callback === 'function') {\n      this.once('close', () => process.nextTick(() => callback()));\n    }\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(options.force, new error_1.MongoNetworkError(message));\n  }\n  /**\r\n   * A method that cleans up the connection.  When `force` is true, this method\r\n   * forcibly destroys the socket.\r\n   *\r\n   * If an error is provided, any in-flight operations will be closed with the error.\r\n   *\r\n   * This method does nothing if the connection is already closed.\r\n   */\n  cleanup(force, error) {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    const completeCleanup = () => {\n      for (const op of this[kQueue].values()) {\n        op.cb(error);\n      }\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    };\n    this[kStream].removeAllListeners();\n    this[kMessageStream].removeAllListeners();\n    this[kMessageStream].destroy();\n    if (force) {\n      this[kStream].destroy();\n      completeCleanup();\n      return;\n    }\n    if (!this[kStream].writableEnded) {\n      this[kStream].end(() => {\n        this[kStream].destroy();\n        completeCleanup();\n      });\n    } else {\n      completeCleanup();\n    }\n  }\n  command(ns, command, options, callback) {\n    let cmd = {\n      ...command\n    };\n    const readPreference = (0, shared_1.getReadPreference)(options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options?.session;\n    let clusterTime = this.clusterTime;\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n      const err = (0, sessions_1.applySession)(session, cmd, options);\n      if (err) {\n        return callback(err);\n      }\n    } else if (session?.explicit) {\n      return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n    }\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n    if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      cmd = {\n        $query: cmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n    const commandOptions = Object.assign({\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, cmd, commandOptions) : new commands_1.Query(cmdNs, cmd, commandOptions);\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n}\n/** @event */\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\nConnection.PINNED = constants_1.PINNED;\n/** @event */\nConnection.UNPINNED = constants_1.UNPINNED;\nexports.Connection = Connection;\n/** @internal */\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n    // Save sort or indexKeys based on the command being run\n    // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n    // and then deserializes the encrypted result, the protocol level components\n    // of the command (ex. sort) are then converted to JS objects potentially losing\n    // import key order information. These fields are never encrypted so we can save the values\n    // from before the encryption and replace them after encryption has been performed\n    const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;\n    const indexKeys = cmd.createIndexes ? cmd.indexes.map(index => index.key) : null;\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n      // Replace the saved values\n      if (sort != null && (cmd.find || cmd.findAndModify)) {\n        encrypted.sort = sort;\n      }\n      if (indexKeys != null && cmd.createIndexes) {\n        for (const [offset, index] of indexKeys.entries()) {\n          encrypted.indexes[offset].key = index;\n        }\n      }\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n}\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n  const {\n    remoteAddress,\n    remotePort\n  } = stream;\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n    return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n  }\n  return (0, utils_1.uuidV4)().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n  options = options ?? {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    // for BSON parsing\n    useBigInt64: typeof options.useBigInt64 === 'boolean' ? options.useBigInt64 : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n  if (typeof options.socketTimeoutMS === 'number') {\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } else if (conn.socketTimeoutMS !== 0) {\n    conn[kStream].setTimeout(conn.socketTimeoutMS);\n  }\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n    operationDescription.cb = (err, reply) => {\n      // Command monitoring spec states that if ok is 1, then we must always emit\n      // a command succeeded event, even if there's an error. Write concern errors\n      // will have an ok: 1 in their reply.\n      if (err && reply?.ok !== 1) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n      if (typeof callback === 'function') {\n        // Since we're passing through the reply with the write concern error now, we\n        // need it not to be provided to the original callback in this case so\n        // retryability does not get tricked into thinking the command actually\n        // succeeded.\n        callback(err, err instanceof error_1.MongoWriteConcernError ? undefined : reply);\n      }\n    };\n  }\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"mappings":"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","names":["kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kHello","kAutoEncrypter","kDelayedTimeoutId","INVALID_QUEUE_SIZE","Connection","mongo_types_1","constructor","stream","options","commandAsync","ns","cmd","callback","command","id","address","streamIdentifier","socketTimeoutMS","monitorCommands","serverApi","closed","stream_description_1","generation","Map","message_stream_1","maxBsonMessageSize","hello","on","message","onMessage","error","onError","onClose","onTimeout","pipe","description","response","receiveResponse","Object","freeze","isMonitoringConnection","value","serviceId","loadBalanced","idleTime","clusterTime","markAvailable","cleanup","error_1","beforeHandshake","unref","delayedTimeoutId","timeout","setTimeout","emit","operationDescription","get","responseTo","size","entry","entries","next","requestId","orphaned","delete","cb","moreToCome","set","parse","err","documents","document","session","$clusterTime","CLUSTER_TIME_RECEIVED","writeConcernError","ok","$err","errmsg","code","undefined","destroy","process","nextTick","once","removeAllListeners","PINNED","UNPINNED","force","completeCleanup","op","values","clear","CLOSE","writableEnded","end","readPreference","shouldUseOpMsg","supportsOpMsg","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","hasSessionSupport","greaterThan","explicit","mode","$query","$readPreference","toJSON","commandOptions","assign","numberToSkip","numberToReturn","checkKeys","secondaryOk","cmdNs","db","commands_1","write","constants_1","exports","CryptoConnection","autoEncrypter","serverWireVersion","sort","find","findAndModify","indexKeys","createIndexes","indexes","map","index","key","encrypt","toString","encrypted","offset","decrypt","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","proxyHost","hostAddress","remoteAddress","remotePort","utils_1","fromHostPort","noResponse","documentsReturnedIn","useBigInt64","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","raw","started","compressor","agreedCompressor","zlibCompressionLevel","COMMAND_STARTED","command_monitoring_events_1","reply","COMMAND_FAILED","COMMAND_SUCCEEDED","writeCommand","e"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\cmap\\connection.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\r\nimport { promisify } from 'util';\r\n\r\nimport type { BSONSerializeOptions, Document, ObjectId } from '../bson';\r\nimport {\r\n  CLOSE,\r\n  CLUSTER_TIME_RECEIVED,\r\n  COMMAND_FAILED,\r\n  COMMAND_STARTED,\r\n  COMMAND_SUCCEEDED,\r\n  MESSAGE,\r\n  PINNED,\r\n  UNPINNED\r\n} from '../constants';\r\nimport type { AutoEncrypter } from '../deps';\r\nimport {\r\n  MongoCompatibilityError,\r\n  MongoMissingDependencyError,\r\n  MongoNetworkError,\r\n  MongoNetworkTimeoutError,\r\n  MongoRuntimeError,\r\n  MongoServerError,\r\n  MongoWriteConcernError\r\n} from '../error';\r\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\r\nimport { type CancellationToken, TypedEventEmitter } from '../mongo_types';\r\nimport type { ReadPreferenceLike } from '../read_preference';\r\nimport { applySession, type ClientSession, updateSessionFromResponse } from '../sessions';\r\nimport {\r\n  calculateDurationInMs,\r\n  type Callback,\r\n  HostAddress,\r\n  maxWireVersion,\r\n  type MongoDBNamespace,\r\n  now,\r\n  uuidV4\r\n} from '../utils';\r\nimport type { WriteConcern } from '../write_concern';\r\nimport type { AuthContext } from './auth/auth_provider';\r\nimport type { MongoCredentials } from './auth/mongo_credentials';\r\nimport {\r\n  CommandFailedEvent,\r\n  CommandStartedEvent,\r\n  CommandSucceededEvent\r\n} from './command_monitoring_events';\r\nimport { type BinMsg, Msg, Query, type Response, type WriteProtocolMessageType } from './commands';\r\nimport type { Stream } from './connect';\r\nimport type { ClientMetadata } from './handshake/client_metadata';\r\nimport { MessageStream, type OperationDescription } from './message_stream';\r\nimport { StreamDescription, type StreamDescriptionOptions } from './stream_description';\r\nimport { getReadPreference, isSharded } from './wire_protocol/shared';\r\n\r\n/** @internal */\r\nconst kStream = Symbol('stream');\r\n/** @internal */\r\nconst kQueue = Symbol('queue');\r\n/** @internal */\r\nconst kMessageStream = Symbol('messageStream');\r\n/** @internal */\r\nconst kGeneration = Symbol('generation');\r\n/** @internal */\r\nconst kLastUseTime = Symbol('lastUseTime');\r\n/** @internal */\r\nconst kClusterTime = Symbol('clusterTime');\r\n/** @internal */\r\nconst kDescription = Symbol('description');\r\n/** @internal */\r\nconst kHello = Symbol('hello');\r\n/** @internal */\r\nconst kAutoEncrypter = Symbol('autoEncrypter');\r\n/** @internal */\r\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\r\n\r\nconst INVALID_QUEUE_SIZE = 'Connection internal queue contains more than 1 operation description';\r\n\r\n/** @internal */\r\nexport interface CommandOptions extends BSONSerializeOptions {\r\n  secondaryOk?: boolean;\r\n  /** Specify read preference if command supports it */\r\n  readPreference?: ReadPreferenceLike;\r\n  monitoring?: boolean;\r\n  socketTimeoutMS?: number;\r\n  /** Session to use for the operation */\r\n  session?: ClientSession;\r\n  documentsReturnedIn?: string;\r\n  noResponse?: boolean;\r\n  omitReadPreference?: boolean;\r\n\r\n  // TODO(NODE-2802): Currently the CommandOptions take a property willRetryWrite which is a hint\r\n  // from executeOperation that the txnNum should be applied to this command.\r\n  // Applying a session to a command should happen as part of command construction,\r\n  // most likely in the CommandOperation#executeCommand method, where we have access to\r\n  // the details we need to determine if a txnNum should also be applied.\r\n  willRetryWrite?: boolean;\r\n\r\n  writeConcern?: WriteConcern;\r\n}\r\n\r\n/** @public */\r\nexport interface ProxyOptions {\r\n  proxyHost?: string;\r\n  proxyPort?: number;\r\n  proxyUsername?: string;\r\n  proxyPassword?: string;\r\n}\r\n\r\n/** @public */\r\nexport interface ConnectionOptions\r\n  extends SupportedNodeConnectionOptions,\r\n    StreamDescriptionOptions,\r\n    ProxyOptions {\r\n  // Internal creation info\r\n  id: number | '<monitor>';\r\n  generation: number;\r\n  hostAddress: HostAddress;\r\n  // Settings\r\n  autoEncrypter?: AutoEncrypter;\r\n  serverApi?: ServerApi;\r\n  monitorCommands: boolean;\r\n  /** @internal */\r\n  connectionType?: typeof Connection;\r\n  credentials?: MongoCredentials;\r\n  connectTimeoutMS?: number;\r\n  tls: boolean;\r\n  /** @deprecated - Will not be able to turn off in the future. */\r\n  keepAlive?: boolean;\r\n  /** @deprecated - Will not be configurable in the future. */\r\n  keepAliveInitialDelay?: number;\r\n  noDelay?: boolean;\r\n  socketTimeoutMS?: number;\r\n  cancellationToken?: CancellationToken;\r\n  metadata: ClientMetadata;\r\n}\r\n\r\n/** @internal */\r\nexport interface DestroyOptions {\r\n  /** Force the destruction. */\r\n  force: boolean;\r\n}\r\n\r\n/** @public */\r\nexport type ConnectionEvents = {\r\n  commandStarted(event: CommandStartedEvent): void;\r\n  commandSucceeded(event: CommandSucceededEvent): void;\r\n  commandFailed(event: CommandFailedEvent): void;\r\n  clusterTimeReceived(clusterTime: Document): void;\r\n  close(): void;\r\n  message(message: any): void;\r\n  pinned(pinType: string): void;\r\n  unpinned(pinType: string): void;\r\n};\r\n\r\n/** @internal */\r\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\r\n  id: number | '<monitor>';\r\n  address: string;\r\n  socketTimeoutMS: number;\r\n  monitorCommands: boolean;\r\n  /** Indicates that the connection (including underlying TCP socket) has been closed. */\r\n  closed: boolean;\r\n  lastHelloMS?: number;\r\n  serverApi?: ServerApi;\r\n  helloOk?: boolean;\r\n  commandAsync: (\r\n    ns: MongoDBNamespace,\r\n    cmd: Document,\r\n    options: CommandOptions | undefined\r\n  ) => Promise<Document>;\r\n  /** @internal */\r\n  authContext?: AuthContext;\r\n\r\n  /**@internal */\r\n  [kDelayedTimeoutId]: NodeJS.Timeout | null;\r\n  /** @internal */\r\n  [kDescription]: StreamDescription;\r\n  /** @internal */\r\n  [kGeneration]: number;\r\n  /** @internal */\r\n  [kLastUseTime]: number;\r\n  /** @internal */\r\n  [kQueue]: Map<number, OperationDescription>;\r\n  /** @internal */\r\n  [kMessageStream]: MessageStream;\r\n  /** @internal */\r\n  [kStream]: Stream;\r\n  /** @internal */\r\n  [kHello]: Document | null;\r\n  /** @internal */\r\n  [kClusterTime]: Document | null;\r\n\r\n  /** @event */\r\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\r\n  /** @event */\r\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\r\n  /** @event */\r\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\r\n  /** @event */\r\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\r\n  /** @event */\r\n  static readonly CLOSE = CLOSE;\r\n  /** @event */\r\n  static readonly MESSAGE = MESSAGE;\r\n  /** @event */\r\n  static readonly PINNED = PINNED;\r\n  /** @event */\r\n  static readonly UNPINNED = UNPINNED;\r\n\r\n  constructor(stream: Stream, options: ConnectionOptions) {\r\n    super();\r\n\r\n    this.commandAsync = promisify(\r\n      (\r\n        ns: MongoDBNamespace,\r\n        cmd: Document,\r\n        options: CommandOptions | undefined,\r\n        callback: Callback\r\n      ) => this.command(ns, cmd, options, callback as any)\r\n    );\r\n\r\n    this.id = options.id;\r\n    this.address = streamIdentifier(stream, options);\r\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\r\n    this.monitorCommands = options.monitorCommands;\r\n    this.serverApi = options.serverApi;\r\n    this.closed = false;\r\n    this[kHello] = null;\r\n    this[kClusterTime] = null;\r\n\r\n    this[kDescription] = new StreamDescription(this.address, options);\r\n    this[kGeneration] = options.generation;\r\n    this[kLastUseTime] = now();\r\n\r\n    // setup parser stream and message handling\r\n    this[kQueue] = new Map();\r\n    this[kMessageStream] = new MessageStream({\r\n      ...options,\r\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\r\n    });\r\n    this[kStream] = stream;\r\n\r\n    this[kDelayedTimeoutId] = null;\r\n\r\n    this[kMessageStream].on('message', message => this.onMessage(message));\r\n    this[kMessageStream].on('error', error => this.onError(error));\r\n    this[kStream].on('close', () => this.onClose());\r\n    this[kStream].on('timeout', () => this.onTimeout());\r\n    this[kStream].on('error', () => {\r\n      /* ignore errors, listen to `close` instead */\r\n    });\r\n\r\n    // hook the message stream up to the passed in stream\r\n    this[kStream].pipe(this[kMessageStream]);\r\n    this[kMessageStream].pipe(this[kStream]);\r\n  }\r\n\r\n  get description(): StreamDescription {\r\n    return this[kDescription];\r\n  }\r\n\r\n  get hello(): Document | null {\r\n    return this[kHello];\r\n  }\r\n\r\n  // the `connect` method stores the result of the handshake hello on the connection\r\n  set hello(response: Document | null) {\r\n    this[kDescription].receiveResponse(response);\r\n    this[kDescription] = Object.freeze(this[kDescription]);\r\n\r\n    // TODO: remove this, and only use the `StreamDescription` in the future\r\n    this[kHello] = response;\r\n  }\r\n\r\n  // Set the whether the message stream is for a monitoring connection.\r\n  set isMonitoringConnection(value: boolean) {\r\n    this[kMessageStream].isMonitoringConnection = value;\r\n  }\r\n\r\n  get isMonitoringConnection(): boolean {\r\n    return this[kMessageStream].isMonitoringConnection;\r\n  }\r\n\r\n  get serviceId(): ObjectId | undefined {\r\n    return this.hello?.serviceId;\r\n  }\r\n\r\n  get loadBalanced(): boolean {\r\n    return this.description.loadBalanced;\r\n  }\r\n\r\n  get generation(): number {\r\n    return this[kGeneration] || 0;\r\n  }\r\n\r\n  set generation(generation: number) {\r\n    this[kGeneration] = generation;\r\n  }\r\n\r\n  get idleTime(): number {\r\n    return calculateDurationInMs(this[kLastUseTime]);\r\n  }\r\n\r\n  get clusterTime(): Document | null {\r\n    return this[kClusterTime];\r\n  }\r\n\r\n  get stream(): Stream {\r\n    return this[kStream];\r\n  }\r\n\r\n  markAvailable(): void {\r\n    this[kLastUseTime] = now();\r\n  }\r\n\r\n  onError(error: Error) {\r\n    this.cleanup(true, error);\r\n  }\r\n\r\n  onClose() {\r\n    const message = `connection ${this.id} to ${this.address} closed`;\r\n    this.cleanup(true, new MongoNetworkError(message));\r\n  }\r\n\r\n  onTimeout() {\r\n    this[kDelayedTimeoutId] = setTimeout(() => {\r\n      const message = `connection ${this.id} to ${this.address} timed out`;\r\n      const beforeHandshake = this.hello == null;\r\n      this.cleanup(true, new MongoNetworkTimeoutError(message, { beforeHandshake }));\r\n    }, 1).unref(); // No need for this timer to hold the event loop open\r\n  }\r\n\r\n  onMessage(message: BinMsg | Response) {\r\n    const delayedTimeoutId = this[kDelayedTimeoutId];\r\n    if (delayedTimeoutId != null) {\r\n      clearTimeout(delayedTimeoutId);\r\n      this[kDelayedTimeoutId] = null;\r\n    }\r\n\r\n    const socketTimeoutMS = this[kStream].timeout ?? 0;\r\n    this[kStream].setTimeout(0);\r\n\r\n    // always emit the message, in case we are streaming\r\n    this.emit('message', message);\r\n    let operationDescription = this[kQueue].get(message.responseTo);\r\n\r\n    if (!operationDescription && this.isMonitoringConnection) {\r\n      // This is how we recover when the initial hello's requestId is not\r\n      // the responseTo when hello responses have been skipped:\r\n\r\n      // First check if the map is of invalid size\r\n      if (this[kQueue].size > 1) {\r\n        this.cleanup(true, new MongoRuntimeError(INVALID_QUEUE_SIZE));\r\n      } else {\r\n        // Get the first orphaned operation description.\r\n        const entry = this[kQueue].entries().next();\r\n        if (entry.value != null) {\r\n          const [requestId, orphaned]: [number, OperationDescription] = entry.value;\r\n          // If the orphaned operation description exists then set it.\r\n          operationDescription = orphaned;\r\n          // Remove the entry with the bad request id from the queue.\r\n          this[kQueue].delete(requestId);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!operationDescription) {\r\n      return;\r\n    }\r\n\r\n    const callback = operationDescription.cb;\r\n\r\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\r\n    // track response, however the server currently synthetically produces remote requests\r\n    // making the `responseTo` change on each response\r\n    this[kQueue].delete(message.responseTo);\r\n    if ('moreToCome' in message && message.moreToCome) {\r\n      // If the operation description check above does find an orphaned\r\n      // description and sets the operationDescription then this line will put one\r\n      // back in the queue with the correct requestId and will resolve not being able\r\n      // to find the next one via the responseTo of the next streaming hello.\r\n      this[kQueue].set(message.requestId, operationDescription);\r\n      this[kStream].setTimeout(socketTimeoutMS);\r\n    }\r\n\r\n    try {\r\n      // Pass in the entire description because it has BSON parsing options\r\n      message.parse(operationDescription);\r\n    } catch (err) {\r\n      // If this error is generated by our own code, it will already have the correct class applied\r\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\r\n      // in either case, it should not be wrapped\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (message.documents[0]) {\r\n      const document: Document = message.documents[0];\r\n      const session = operationDescription.session;\r\n      if (session) {\r\n        updateSessionFromResponse(session, document);\r\n      }\r\n\r\n      if (document.$clusterTime) {\r\n        this[kClusterTime] = document.$clusterTime;\r\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\r\n      }\r\n\r\n      if (document.writeConcernError) {\r\n        callback(new MongoWriteConcernError(document.writeConcernError, document), document);\r\n        return;\r\n      }\r\n\r\n      if (document.ok === 0 || document.$err || document.errmsg || document.code) {\r\n        callback(new MongoServerError(document));\r\n        return;\r\n      }\r\n    }\r\n\r\n    callback(undefined, message.documents[0]);\r\n  }\r\n\r\n  destroy(options: DestroyOptions, callback?: Callback): void {\r\n    if (this.closed) {\r\n      process.nextTick(() => callback?.());\r\n      return;\r\n    }\r\n    if (typeof callback === 'function') {\r\n      this.once('close', () => process.nextTick(() => callback()));\r\n    }\r\n\r\n    // load balanced mode requires that these listeners remain on the connection\r\n    // after cleanup on timeouts, errors or close so we remove them before calling\r\n    // cleanup.\r\n    this.removeAllListeners(Connection.PINNED);\r\n    this.removeAllListeners(Connection.UNPINNED);\r\n    const message = `connection ${this.id} to ${this.address} closed`;\r\n    this.cleanup(options.force, new MongoNetworkError(message));\r\n  }\r\n\r\n  /**\r\n   * A method that cleans up the connection.  When `force` is true, this method\r\n   * forcibly destroys the socket.\r\n   *\r\n   * If an error is provided, any in-flight operations will be closed with the error.\r\n   *\r\n   * This method does nothing if the connection is already closed.\r\n   */\r\n  private cleanup(force: boolean, error?: Error): void {\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    this.closed = true;\r\n\r\n    const completeCleanup = () => {\r\n      for (const op of this[kQueue].values()) {\r\n        op.cb(error);\r\n      }\r\n\r\n      this[kQueue].clear();\r\n\r\n      this.emit(Connection.CLOSE);\r\n    };\r\n\r\n    this[kStream].removeAllListeners();\r\n    this[kMessageStream].removeAllListeners();\r\n\r\n    this[kMessageStream].destroy();\r\n\r\n    if (force) {\r\n      this[kStream].destroy();\r\n      completeCleanup();\r\n      return;\r\n    }\r\n\r\n    if (!this[kStream].writableEnded) {\r\n      this[kStream].end(() => {\r\n        this[kStream].destroy();\r\n        completeCleanup();\r\n      });\r\n    } else {\r\n      completeCleanup();\r\n    }\r\n  }\r\n\r\n  command(\r\n    ns: MongoDBNamespace,\r\n    command: Document,\r\n    options: CommandOptions | undefined,\r\n    callback: Callback\r\n  ): void {\r\n    let cmd = { ...command };\r\n\r\n    const readPreference = getReadPreference(options);\r\n    const shouldUseOpMsg = supportsOpMsg(this);\r\n    const session = options?.session;\r\n\r\n    let clusterTime = this.clusterTime;\r\n\r\n    if (this.serverApi) {\r\n      const { version, strict, deprecationErrors } = this.serverApi;\r\n      cmd.apiVersion = version;\r\n      if (strict != null) cmd.apiStrict = strict;\r\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\r\n    }\r\n\r\n    if (hasSessionSupport(this) && session) {\r\n      if (\r\n        session.clusterTime &&\r\n        clusterTime &&\r\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\r\n      ) {\r\n        clusterTime = session.clusterTime;\r\n      }\r\n\r\n      const err = applySession(session, cmd, options);\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n    } else if (session?.explicit) {\r\n      return callback(new MongoCompatibilityError('Current topology does not support sessions'));\r\n    }\r\n\r\n    // if we have a known cluster time, gossip it\r\n    if (clusterTime) {\r\n      cmd.$clusterTime = clusterTime;\r\n    }\r\n\r\n    if (isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\r\n      cmd = {\r\n        $query: cmd,\r\n        $readPreference: readPreference.toJSON()\r\n      };\r\n    }\r\n\r\n    const commandOptions: Document = Object.assign(\r\n      {\r\n        numberToSkip: 0,\r\n        numberToReturn: -1,\r\n        checkKeys: false,\r\n        // This value is not overridable\r\n        secondaryOk: readPreference.secondaryOk()\r\n      },\r\n      options\r\n    );\r\n\r\n    const cmdNs = `${ns.db}.$cmd`;\r\n    const message = shouldUseOpMsg\r\n      ? new Msg(cmdNs, cmd, commandOptions)\r\n      : new Query(cmdNs, cmd, commandOptions);\r\n\r\n    try {\r\n      write(this, message, commandOptions, callback);\r\n    } catch (err) {\r\n      callback(err);\r\n    }\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class CryptoConnection extends Connection {\r\n  /** @internal */\r\n  [kAutoEncrypter]?: AutoEncrypter;\r\n\r\n  constructor(stream: Stream, options: ConnectionOptions) {\r\n    super(stream, options);\r\n    this[kAutoEncrypter] = options.autoEncrypter;\r\n  }\r\n\r\n  /** @internal @override */\r\n  override command(\r\n    ns: MongoDBNamespace,\r\n    cmd: Document,\r\n    options: CommandOptions,\r\n    callback: Callback\r\n  ): void {\r\n    const autoEncrypter = this[kAutoEncrypter];\r\n    if (!autoEncrypter) {\r\n      return callback(new MongoMissingDependencyError('No AutoEncrypter available for encryption'));\r\n    }\r\n\r\n    const serverWireVersion = maxWireVersion(this);\r\n    if (serverWireVersion === 0) {\r\n      // This means the initial handshake hasn't happened yet\r\n      return super.command(ns, cmd, options, callback);\r\n    }\r\n\r\n    if (serverWireVersion < 8) {\r\n      callback(\r\n        new MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2')\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Save sort or indexKeys based on the command being run\r\n    // the encrypt API serializes our JS objects to BSON to pass to the native code layer\r\n    // and then deserializes the encrypted result, the protocol level components\r\n    // of the command (ex. sort) are then converted to JS objects potentially losing\r\n    // import key order information. These fields are never encrypted so we can save the values\r\n    // from before the encryption and replace them after encryption has been performed\r\n    const sort: Map<string, number> | null = cmd.find || cmd.findAndModify ? cmd.sort : null;\r\n    const indexKeys: Map<string, number>[] | null = cmd.createIndexes\r\n      ? cmd.indexes.map((index: { key: Map<string, number> }) => index.key)\r\n      : null;\r\n\r\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\r\n      if (err || encrypted == null) {\r\n        callback(err, null);\r\n        return;\r\n      }\r\n\r\n      // Replace the saved values\r\n      if (sort != null && (cmd.find || cmd.findAndModify)) {\r\n        encrypted.sort = sort;\r\n      }\r\n      if (indexKeys != null && cmd.createIndexes) {\r\n        for (const [offset, index] of indexKeys.entries()) {\r\n          encrypted.indexes[offset].key = index;\r\n        }\r\n      }\r\n\r\n      super.command(ns, encrypted, options, (err, response) => {\r\n        if (err || response == null) {\r\n          callback(err, response);\r\n          return;\r\n        }\r\n\r\n        autoEncrypter.decrypt(response, options, callback);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport function hasSessionSupport(conn: Connection): boolean {\r\n  const description = conn.description;\r\n  return description.logicalSessionTimeoutMinutes != null;\r\n}\r\n\r\nfunction supportsOpMsg(conn: Connection) {\r\n  const description = conn.description;\r\n  if (description == null) {\r\n    return false;\r\n  }\r\n\r\n  return maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\r\n}\r\n\r\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\r\n  if (options.proxyHost) {\r\n    // If proxy options are specified, the properties of `stream` itself\r\n    // will not accurately reflect what endpoint this is connected to.\r\n    return options.hostAddress.toString();\r\n  }\r\n\r\n  const { remoteAddress, remotePort } = stream;\r\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\r\n    return HostAddress.fromHostPort(remoteAddress, remotePort).toString();\r\n  }\r\n\r\n  return uuidV4().toString('hex');\r\n}\r\n\r\nfunction write(\r\n  conn: Connection,\r\n  command: WriteProtocolMessageType,\r\n  options: CommandOptions,\r\n  callback: Callback\r\n) {\r\n  options = options ?? {};\r\n  const operationDescription: OperationDescription = {\r\n    requestId: command.requestId,\r\n    cb: callback,\r\n    session: options.session,\r\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\r\n    documentsReturnedIn: options.documentsReturnedIn,\r\n\r\n    // for BSON parsing\r\n    useBigInt64: typeof options.useBigInt64 === 'boolean' ? options.useBigInt64 : false,\r\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\r\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\r\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\r\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\r\n    enableUtf8Validation:\r\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\r\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\r\n    started: 0\r\n  };\r\n\r\n  if (conn[kDescription] && conn[kDescription].compressor) {\r\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\r\n\r\n    if (conn[kDescription].zlibCompressionLevel) {\r\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\r\n    }\r\n  }\r\n\r\n  if (typeof options.socketTimeoutMS === 'number') {\r\n    conn[kStream].setTimeout(options.socketTimeoutMS);\r\n  } else if (conn.socketTimeoutMS !== 0) {\r\n    conn[kStream].setTimeout(conn.socketTimeoutMS);\r\n  }\r\n\r\n  // if command monitoring is enabled we need to modify the callback here\r\n  if (conn.monitorCommands) {\r\n    conn.emit(Connection.COMMAND_STARTED, new CommandStartedEvent(conn, command));\r\n\r\n    operationDescription.started = now();\r\n    operationDescription.cb = (err, reply) => {\r\n      // Command monitoring spec states that if ok is 1, then we must always emit\r\n      // a command succeeded event, even if there's an error. Write concern errors\r\n      // will have an ok: 1 in their reply.\r\n      if (err && reply?.ok !== 1) {\r\n        conn.emit(\r\n          Connection.COMMAND_FAILED,\r\n          new CommandFailedEvent(conn, command, err, operationDescription.started)\r\n        );\r\n      } else {\r\n        if (reply && (reply.ok === 0 || reply.$err)) {\r\n          conn.emit(\r\n            Connection.COMMAND_FAILED,\r\n            new CommandFailedEvent(conn, command, reply, operationDescription.started)\r\n          );\r\n        } else {\r\n          conn.emit(\r\n            Connection.COMMAND_SUCCEEDED,\r\n            new CommandSucceededEvent(conn, command, reply, operationDescription.started)\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        // Since we're passing through the reply with the write concern error now, we\r\n        // need it not to be provided to the original callback in this case so\r\n        // retryability does not get tricked into thinking the command actually\r\n        // succeeded.\r\n        callback(err, err instanceof MongoWriteConcernError ? undefined : reply);\r\n      }\r\n    };\r\n  }\r\n\r\n  if (!operationDescription.noResponse) {\r\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\r\n  }\r\n\r\n  try {\r\n    conn[kMessageStream].writeCommand(command, operationDescription);\r\n  } catch (e) {\r\n    if (!operationDescription.noResponse) {\r\n      conn[kQueue].delete(operationDescription.requestId);\r\n      operationDescription.cb(e);\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (operationDescription.noResponse) {\r\n    operationDescription.cb();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}