{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IsCappedOperation = void 0;\nconst error_1 = require(\"../error\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass IsCappedOperation extends operation_1.AbstractCallbackOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n  executeCallback(server, session, callback) {\n    const coll = this.collection;\n    coll.s.db.listCollections({\n      name: coll.collectionName\n    }, {\n      ...this.options,\n      nameOnly: false,\n      readPreference: this.readPreference,\n      session\n    }).toArray().then(collections => {\n      if (collections.length === 0) {\n        // TODO(NODE-3485)\n        return callback(new error_1.MongoAPIError(`collection ${coll.namespace} not found`));\n      }\n      callback(undefined, !!collections[0].options?.capped);\n    }, error => callback(error));\n  }\n}\nexports.IsCappedOperation = IsCappedOperation;","map":{"version":3,"mappings":";;;;;;AACA;AAIA;AAEA;AACA,MAAaA,iBAAkB,SAAQC,qCAAkC;EAIvEC,YAAYC,UAAsB,EAAEC,OAAyB;IAC3D,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACD,UAAU,GAAGA,UAAU;EAC9B;EAESE,eAAe,CACtBC,MAAc,EACdC,OAAkC,EAClCC,QAA2B;IAE3B,MAAMC,IAAI,GAAG,IAAI,CAACN,UAAU;IAE5BM,IAAI,CAACC,CAAC,CAACC,EAAE,CACNC,eAAe,CACd;MAAEC,IAAI,EAAEJ,IAAI,CAACK;IAAc,CAAE,EAC7B;MAAE,GAAG,IAAI,CAACV,OAAO;MAAEW,QAAQ,EAAE,KAAK;MAAEC,cAAc,EAAE,IAAI,CAACA,cAAc;MAAET;IAAO,CAAE,CACnF,CACAU,OAAO,EAAE,CACTC,IAAI,CACHC,WAAW,IAAG;MACZ,IAAIA,WAAW,CAACC,MAAM,KAAK,CAAC,EAAE;QAC5B;QACA,OAAOZ,QAAQ,CAAC,IAAIa,qBAAa,CAAC,cAAcZ,IAAI,CAACa,SAAS,YAAY,CAAC,CAAC;;MAG9Ed,QAAQ,CAACe,SAAS,EAAE,CAAC,CAACJ,WAAW,CAAC,CAAC,CAAC,CAACf,OAAO,EAAEoB,MAAM,CAAC;IACvD,CAAC,EACDC,KAAK,IAAIjB,QAAQ,CAACiB,KAAK,CAAC,CACzB;EACL;;AAlCFC","names":["IsCappedOperation","operation_1","constructor","collection","options","executeCallback","server","session","callback","coll","s","db","listCollections","name","collectionName","nameOnly","readPreference","toArray","then","collections","length","error_1","namespace","undefined","capped","error","exports"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\operations\\is_capped.ts"],"sourcesContent":["import type { Collection } from '../collection';\r\nimport { MongoAPIError } from '../error';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport type { Callback } from '../utils';\r\nimport { AbstractCallbackOperation, type OperationOptions } from './operation';\r\n\r\n/** @internal */\r\nexport class IsCappedOperation extends AbstractCallbackOperation<boolean> {\r\n  override options: OperationOptions;\r\n  collection: Collection;\r\n\r\n  constructor(collection: Collection, options: OperationOptions) {\r\n    super(options);\r\n    this.options = options;\r\n    this.collection = collection;\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<boolean>\r\n  ): void {\r\n    const coll = this.collection;\r\n\r\n    coll.s.db\r\n      .listCollections(\r\n        { name: coll.collectionName },\r\n        { ...this.options, nameOnly: false, readPreference: this.readPreference, session }\r\n      )\r\n      .toArray()\r\n      .then(\r\n        collections => {\r\n          if (collections.length === 0) {\r\n            // TODO(NODE-3485)\r\n            return callback(new MongoAPIError(`collection ${coll.namespace} not found`));\r\n          }\r\n\r\n          callback(undefined, !!collections[0].options?.capped);\r\n        },\r\n        error => callback(error)\r\n      );\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}