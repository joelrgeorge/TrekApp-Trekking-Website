{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;\nconst error_1 = require(\"../error\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass DropCollectionOperation extends command_1.CommandCallbackOperation {\n  constructor(db, name, options = {}) {\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n  executeCallback(server, session, callback) {\n    (async () => {\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n      const encryptedFieldsMap = db.client.options.autoEncryption?.encryptedFieldsMap;\n      let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configured with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db.listCollections({\n          name\n        }, {\n          nameOnly: false\n        }).toArray();\n        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n      }\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n        for (const collectionName of [escCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n              throw err;\n            }\n          }\n        }\n      }\n      return this.executeWithoutEncryptedFieldsCheck(server, session);\n    })().then(result => callback(undefined, result), err => callback(err));\n  }\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      super.executeCommandCallback(server, session, {\n        drop: this.name\n      }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n}\nexports.DropCollectionOperation = DropCollectionOperation;\n/** @internal */\nclass DropDatabaseOperation extends command_1.CommandCallbackOperation {\n  constructor(db, options) {\n    super(db, options);\n    this.options = options;\n  }\n  executeCallback(server, session, callback) {\n    super.executeCommandCallback(server, session, {\n      dropDatabase: 1\n    }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n}\nexports.DropDatabaseOperation = DropDatabaseOperation;\n(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["DropCollectionOperation","command_1","constructor","db","name","options","executeCallback","server","session","callback","encryptedFieldsMap","client","autoEncryption","encryptedFields","databaseName","listCollectionsResult","listCollections","nameOnly","toArray","escCollection","ecocCollection","collectionName","dropOp","executeWithoutEncryptedFieldsCheck","err","error_1","code","NamespaceNotFound","then","result","undefined","Promise","resolve","reject","executeCommandCallback","drop","ok","exports","DropDatabaseOperation","dropDatabase","operation_1","WRITE_OPERATION"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\operations\\drop.ts"],"sourcesContent":["import type { Document } from '../bson';\r\nimport type { Db } from '../db';\r\nimport { MONGODB_ERROR_CODES, MongoServerError } from '../error';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport type { Callback } from '../utils';\r\nimport { CommandCallbackOperation, type CommandOperationOptions } from './command';\r\nimport { Aspect, defineAspects } from './operation';\r\n\r\n/** @public */\r\nexport interface DropCollectionOptions extends CommandOperationOptions {\r\n  /** @experimental */\r\n  encryptedFields?: Document;\r\n}\r\n\r\n/** @internal */\r\nexport class DropCollectionOperation extends CommandCallbackOperation<boolean> {\r\n  override options: DropCollectionOptions;\r\n  db: Db;\r\n  name: string;\r\n\r\n  constructor(db: Db, name: string, options: DropCollectionOptions = {}) {\r\n    super(db, options);\r\n    this.db = db;\r\n    this.options = options;\r\n    this.name = name;\r\n  }\r\n\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<boolean>\r\n  ): void {\r\n    (async () => {\r\n      const db = this.db;\r\n      const options = this.options;\r\n      const name = this.name;\r\n\r\n      const encryptedFieldsMap = db.client.options.autoEncryption?.encryptedFieldsMap;\r\n      let encryptedFields: Document | undefined =\r\n        options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\r\n\r\n      if (!encryptedFields && encryptedFieldsMap) {\r\n        // If the MongoClient was configured with an encryptedFieldsMap,\r\n        // and no encryptedFields config was available in it or explicitly\r\n        // passed as an argument, the spec tells us to look one up using\r\n        // listCollections().\r\n        const listCollectionsResult = await db\r\n          .listCollections({ name }, { nameOnly: false })\r\n          .toArray();\r\n        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\r\n      }\r\n\r\n      if (encryptedFields) {\r\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\r\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\r\n\r\n        for (const collectionName of [escCollection, ecocCollection]) {\r\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\r\n          const dropOp = new DropCollectionOperation(db, collectionName);\r\n          try {\r\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\r\n          } catch (err) {\r\n            if (\r\n              !(err instanceof MongoServerError) ||\r\n              err.code !== MONGODB_ERROR_CODES.NamespaceNotFound\r\n            ) {\r\n              throw err;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return this.executeWithoutEncryptedFieldsCheck(server, session);\r\n    })().then(\r\n      result => callback(undefined, result),\r\n      err => callback(err)\r\n    );\r\n  }\r\n\r\n  private executeWithoutEncryptedFieldsCheck(\r\n    server: Server,\r\n    session: ClientSession | undefined\r\n  ): Promise<boolean> {\r\n    return new Promise<boolean>((resolve, reject) => {\r\n      super.executeCommandCallback(server, session, { drop: this.name }, (err, result) => {\r\n        if (err) return reject(err);\r\n        resolve(!!result.ok);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\n/** @public */\r\nexport type DropDatabaseOptions = CommandOperationOptions;\r\n\r\n/** @internal */\r\nexport class DropDatabaseOperation extends CommandCallbackOperation<boolean> {\r\n  override options: DropDatabaseOptions;\r\n\r\n  constructor(db: Db, options: DropDatabaseOptions) {\r\n    super(db, options);\r\n    this.options = options;\r\n  }\r\n  override executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<boolean>\r\n  ): void {\r\n    super.executeCommandCallback(server, session, { dropDatabase: 1 }, (err, result) => {\r\n      if (err) return callback(err);\r\n      if (result.ok) return callback(undefined, true);\r\n      callback(undefined, false);\r\n    });\r\n  }\r\n}\r\n\r\ndefineAspects(DropCollectionOperation, [Aspect.WRITE_OPERATION]);\r\ndefineAspects(DropDatabaseOperation, [Aspect.WRITE_OPERATION]);\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}