{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\nconst crypto = require(\"crypto\");\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"../../bson\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\nconst providers_1 = require(\"./providers\");\nclass ScramSHA extends auth_provider_1.AuthProvider {\n  constructor(cryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n    this.randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);\n  }\n  async prepare(handshakeDoc, authContext) {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n    if (cryptoMethod === 'sha256' && ('kModuleError' in deps_1.saslprep || typeof deps_1.saslprep !== 'function')) {\n      (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n    const nonce = await this.randomBytesAsync(24);\n    // store the nonce for later use\n    authContext.nonce = nonce;\n    const request = {\n      ...handshakeDoc,\n      speculativeAuthenticate: {\n        ...makeFirstMessage(cryptoMethod, credentials, nonce),\n        db: credentials.source\n      }\n    };\n    return request;\n  }\n  async auth(authContext) {\n    const {\n      reauthenticating,\n      response\n    } = authContext;\n    if (response?.speculativeAuthenticate && !reauthenticating) {\n      return continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);\n    }\n    return executeScram(this.cryptoMethod, authContext);\n  }\n}\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\nasync function executeScram(cryptoMethod, authContext) {\n  const {\n    connection,\n    credentials\n  } = authContext;\n  if (!credentials) {\n    throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n  }\n  if (!authContext.nonce) {\n    throw new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property');\n  }\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  const response = await connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, undefined);\n  await continueScramConversation(cryptoMethod, response, authContext);\n}\nasync function continueScramConversation(cryptoMethod, response, authContext) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  if (!credentials) {\n    throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n  }\n  if (!authContext.nonce) {\n    throw new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');\n  }\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in deps_1.saslprep || typeof deps_1.saslprep !== 'function' ? password : (0, deps_1.saslprep)(password);\n  } else {\n    processedPassword = passwordDigest(username, password);\n  }\n  const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);\n  }\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);\n  }\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new bson_1.Binary(Buffer.from(clientFinal))\n  };\n  const r = await connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, undefined);\n  const parsedResponse = parsePayload(r.payload.value());\n  if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n    throw new error_1.MongoRuntimeError('Server returned an invalid signature');\n  }\n  if (r.done !== false) {\n    // If the server sends r.done === true we can save one RTT\n    return;\n  }\n  const retrySaslContinueCmd = {\n    saslContinue: 1,\n    conversationId: r.conversationId,\n    payload: Buffer.alloc(0)\n  };\n  await connection.commandAsync((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, undefined);\n}\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n  return dict;\n}\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Username must be a string');\n  }\n  if (typeof password !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Password must be a string');\n  }\n  if (password.length === 0) {\n    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n  }\n  let md5;\n  try {\n    md5 = crypto.createHash('md5');\n  } catch (err) {\n    if (crypto.getFips()) {\n      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n    }\n    throw err;\n  }\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n  const length = Math.max(a.length, b.length);\n  const res = [];\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n  return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  }\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n  return result === 0;\n}\nclass ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n}\nexports.ScramSHA1 = ScramSHA1;\nclass ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n}\nexports.ScramSHA256 = ScramSHA256;","map":{"version":3,"mappings":"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","names":["ScramSHA","auth_provider_1","constructor","cryptoMethod","randomBytesAsync","crypto","randomBytes","prepare","handshakeDoc","authContext","credentials","error_1","deps_1","nonce","request","speculativeAuthenticate","makeFirstMessage","db","source","auth","reauthenticating","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","Buffer","concat","from","toString","mechanism","providers_1","MONGODB_SCRAM_SHA1","MONGODB_SCRAM_SHA256","saslStart","payload","bson_1","autoAuthorize","options","skipEmptyExchange","connection","saslStartCmd","commandAsync","undefined","password","processedPassword","passwordDigest","isBuffer","dict","parsePayload","value","iterations","parseInt","i","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","err","getFips","Error","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","result","ScramSHA1","exports","ScramSHA256"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\cmap\\auth\\scram.ts"],"sourcesContent":["import * as crypto from 'crypto';\r\nimport { promisify } from 'util';\r\n\r\nimport { Binary, type Document } from '../../bson';\r\nimport { saslprep } from '../../deps';\r\nimport {\r\n  MongoInvalidArgumentError,\r\n  MongoMissingCredentialsError,\r\n  MongoRuntimeError\r\n} from '../../error';\r\nimport { emitWarning, ns } from '../../utils';\r\nimport type { HandshakeDocument } from '../connect';\r\nimport { type AuthContext, AuthProvider } from './auth_provider';\r\nimport type { MongoCredentials } from './mongo_credentials';\r\nimport { AuthMechanism } from './providers';\r\n\r\ntype CryptoMethod = 'sha1' | 'sha256';\r\n\r\nclass ScramSHA extends AuthProvider {\r\n  cryptoMethod: CryptoMethod;\r\n  randomBytesAsync: (size: number) => Promise<Buffer>;\r\n  constructor(cryptoMethod: CryptoMethod) {\r\n    super();\r\n    this.cryptoMethod = cryptoMethod || 'sha1';\r\n    this.randomBytesAsync = promisify(crypto.randomBytes);\r\n  }\r\n\r\n  override async prepare(\r\n    handshakeDoc: HandshakeDocument,\r\n    authContext: AuthContext\r\n  ): Promise<HandshakeDocument> {\r\n    const cryptoMethod = this.cryptoMethod;\r\n    const credentials = authContext.credentials;\r\n    if (!credentials) {\r\n      throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\r\n    }\r\n    if (\r\n      cryptoMethod === 'sha256' &&\r\n      ('kModuleError' in saslprep || typeof saslprep !== 'function')\r\n    ) {\r\n      emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\r\n    }\r\n\r\n    const nonce = await this.randomBytesAsync(24);\r\n    // store the nonce for later use\r\n    authContext.nonce = nonce;\r\n\r\n    const request = {\r\n      ...handshakeDoc,\r\n      speculativeAuthenticate: {\r\n        ...makeFirstMessage(cryptoMethod, credentials, nonce),\r\n        db: credentials.source\r\n      }\r\n    };\r\n\r\n    return request;\r\n  }\r\n\r\n  override async auth(authContext: AuthContext) {\r\n    const { reauthenticating, response } = authContext;\r\n    if (response?.speculativeAuthenticate && !reauthenticating) {\r\n      return continueScramConversation(\r\n        this.cryptoMethod,\r\n        response.speculativeAuthenticate,\r\n        authContext\r\n      );\r\n    }\r\n    return executeScram(this.cryptoMethod, authContext);\r\n  }\r\n}\r\n\r\nfunction cleanUsername(username: string) {\r\n  return username.replace('=', '=3D').replace(',', '=2C');\r\n}\r\n\r\nfunction clientFirstMessageBare(username: string, nonce: Buffer) {\r\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\r\n  // Since the username is not sasl-prep-d, we need to do this here.\r\n  return Buffer.concat([\r\n    Buffer.from('n=', 'utf8'),\r\n    Buffer.from(username, 'utf8'),\r\n    Buffer.from(',r=', 'utf8'),\r\n    Buffer.from(nonce.toString('base64'), 'utf8')\r\n  ]);\r\n}\r\n\r\nfunction makeFirstMessage(\r\n  cryptoMethod: CryptoMethod,\r\n  credentials: MongoCredentials,\r\n  nonce: Buffer\r\n) {\r\n  const username = cleanUsername(credentials.username);\r\n  const mechanism =\r\n    cryptoMethod === 'sha1' ? AuthMechanism.MONGODB_SCRAM_SHA1 : AuthMechanism.MONGODB_SCRAM_SHA256;\r\n\r\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\r\n  // Since the username is not sasl-prep-d, we need to do this here.\r\n  return {\r\n    saslStart: 1,\r\n    mechanism,\r\n    payload: new Binary(\r\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\r\n    ),\r\n    autoAuthorize: 1,\r\n    options: { skipEmptyExchange: true }\r\n  };\r\n}\r\n\r\nasync function executeScram(cryptoMethod: CryptoMethod, authContext: AuthContext): Promise<void> {\r\n  const { connection, credentials } = authContext;\r\n  if (!credentials) {\r\n    throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\r\n  }\r\n  if (!authContext.nonce) {\r\n    throw new MongoInvalidArgumentError('AuthContext must contain a valid nonce property');\r\n  }\r\n  const nonce = authContext.nonce;\r\n  const db = credentials.source;\r\n\r\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\r\n  const response = await connection.commandAsync(ns(`${db}.$cmd`), saslStartCmd, undefined);\r\n  await continueScramConversation(cryptoMethod, response, authContext);\r\n}\r\n\r\nasync function continueScramConversation(\r\n  cryptoMethod: CryptoMethod,\r\n  response: Document,\r\n  authContext: AuthContext\r\n): Promise<void> {\r\n  const connection = authContext.connection;\r\n  const credentials = authContext.credentials;\r\n  if (!credentials) {\r\n    throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\r\n  }\r\n  if (!authContext.nonce) {\r\n    throw new MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce');\r\n  }\r\n  const nonce = authContext.nonce;\r\n\r\n  const db = credentials.source;\r\n  const username = cleanUsername(credentials.username);\r\n  const password = credentials.password;\r\n\r\n  let processedPassword;\r\n  if (cryptoMethod === 'sha256') {\r\n    processedPassword =\r\n      'kModuleError' in saslprep || typeof saslprep !== 'function' ? password : saslprep(password);\r\n  } else {\r\n    processedPassword = passwordDigest(username, password);\r\n  }\r\n\r\n  const payload = Buffer.isBuffer(response.payload)\r\n    ? new Binary(response.payload)\r\n    : response.payload;\r\n  const dict = parsePayload(payload.value());\r\n\r\n  const iterations = parseInt(dict.i, 10);\r\n  if (iterations && iterations < 4096) {\r\n    // TODO(NODE-3483)\r\n    throw new MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);\r\n  }\r\n\r\n  const salt = dict.s;\r\n  const rnonce = dict.r;\r\n  if (rnonce.startsWith('nonce')) {\r\n    // TODO(NODE-3483)\r\n    throw new MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);\r\n  }\r\n\r\n  // Set up start of proof\r\n  const withoutProof = `c=biws,r=${rnonce}`;\r\n  const saltedPassword = HI(\r\n    processedPassword,\r\n    Buffer.from(salt, 'base64'),\r\n    iterations,\r\n    cryptoMethod\r\n  );\r\n\r\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\r\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\r\n  const storedKey = H(cryptoMethod, clientKey);\r\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(\r\n    ','\r\n  );\r\n\r\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\r\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\r\n  const clientFinal = [withoutProof, clientProof].join(',');\r\n\r\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\r\n  const saslContinueCmd = {\r\n    saslContinue: 1,\r\n    conversationId: response.conversationId,\r\n    payload: new Binary(Buffer.from(clientFinal))\r\n  };\r\n\r\n  const r = await connection.commandAsync(ns(`${db}.$cmd`), saslContinueCmd, undefined);\r\n  const parsedResponse = parsePayload(r.payload.value());\r\n\r\n  if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\r\n    throw new MongoRuntimeError('Server returned an invalid signature');\r\n  }\r\n\r\n  if (r.done !== false) {\r\n    // If the server sends r.done === true we can save one RTT\r\n    return;\r\n  }\r\n\r\n  const retrySaslContinueCmd = {\r\n    saslContinue: 1,\r\n    conversationId: r.conversationId,\r\n    payload: Buffer.alloc(0)\r\n  };\r\n\r\n  await connection.commandAsync(ns(`${db}.$cmd`), retrySaslContinueCmd, undefined);\r\n}\r\n\r\nfunction parsePayload(payload: string) {\r\n  const dict: Document = {};\r\n  const parts = payload.split(',');\r\n  for (let i = 0; i < parts.length; i++) {\r\n    const valueParts = parts[i].split('=');\r\n    dict[valueParts[0]] = valueParts[1];\r\n  }\r\n\r\n  return dict;\r\n}\r\n\r\nfunction passwordDigest(username: string, password: string) {\r\n  if (typeof username !== 'string') {\r\n    throw new MongoInvalidArgumentError('Username must be a string');\r\n  }\r\n\r\n  if (typeof password !== 'string') {\r\n    throw new MongoInvalidArgumentError('Password must be a string');\r\n  }\r\n\r\n  if (password.length === 0) {\r\n    throw new MongoInvalidArgumentError('Password cannot be empty');\r\n  }\r\n\r\n  let md5: crypto.Hash;\r\n  try {\r\n    md5 = crypto.createHash('md5');\r\n  } catch (err) {\r\n    if (crypto.getFips()) {\r\n      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\r\n      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\r\n      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\r\n    }\r\n    throw err;\r\n  }\r\n  md5.update(`${username}:mongo:${password}`, 'utf8');\r\n  return md5.digest('hex');\r\n}\r\n\r\n// XOR two buffers\r\nfunction xor(a: Buffer, b: Buffer) {\r\n  if (!Buffer.isBuffer(a)) {\r\n    a = Buffer.from(a);\r\n  }\r\n\r\n  if (!Buffer.isBuffer(b)) {\r\n    b = Buffer.from(b);\r\n  }\r\n\r\n  const length = Math.max(a.length, b.length);\r\n  const res = [];\r\n\r\n  for (let i = 0; i < length; i += 1) {\r\n    res.push(a[i] ^ b[i]);\r\n  }\r\n\r\n  return Buffer.from(res).toString('base64');\r\n}\r\n\r\nfunction H(method: CryptoMethod, text: Buffer) {\r\n  return crypto.createHash(method).update(text).digest();\r\n}\r\n\r\nfunction HMAC(method: CryptoMethod, key: Buffer, text: Buffer | string) {\r\n  return crypto.createHmac(method, key).update(text).digest();\r\n}\r\n\r\ninterface HICache {\r\n  [key: string]: Buffer;\r\n}\r\n\r\nlet _hiCache: HICache = {};\r\nlet _hiCacheCount = 0;\r\nfunction _hiCachePurge() {\r\n  _hiCache = {};\r\n  _hiCacheCount = 0;\r\n}\r\n\r\nconst hiLengthMap = {\r\n  sha256: 32,\r\n  sha1: 20\r\n};\r\n\r\nfunction HI(data: string, salt: Buffer, iterations: number, cryptoMethod: CryptoMethod) {\r\n  // omit the work if already generated\r\n  const key = [data, salt.toString('base64'), iterations].join('_');\r\n  if (_hiCache[key] != null) {\r\n    return _hiCache[key];\r\n  }\r\n\r\n  // generate the salt\r\n  const saltedData = crypto.pbkdf2Sync(\r\n    data,\r\n    salt,\r\n    iterations,\r\n    hiLengthMap[cryptoMethod],\r\n    cryptoMethod\r\n  );\r\n\r\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\r\n  if (_hiCacheCount >= 200) {\r\n    _hiCachePurge();\r\n  }\r\n\r\n  _hiCache[key] = saltedData;\r\n  _hiCacheCount += 1;\r\n  return saltedData;\r\n}\r\n\r\nfunction compareDigest(lhs: Buffer, rhs: Uint8Array) {\r\n  if (lhs.length !== rhs.length) {\r\n    return false;\r\n  }\r\n\r\n  if (typeof crypto.timingSafeEqual === 'function') {\r\n    return crypto.timingSafeEqual(lhs, rhs);\r\n  }\r\n\r\n  let result = 0;\r\n  for (let i = 0; i < lhs.length; i++) {\r\n    result |= lhs[i] ^ rhs[i];\r\n  }\r\n\r\n  return result === 0;\r\n}\r\n\r\nexport class ScramSHA1 extends ScramSHA {\r\n  constructor() {\r\n    super('sha1');\r\n  }\r\n}\r\n\r\nexport class ScramSHA256 extends ScramSHA {\r\n  constructor() {\r\n    super('sha256');\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}