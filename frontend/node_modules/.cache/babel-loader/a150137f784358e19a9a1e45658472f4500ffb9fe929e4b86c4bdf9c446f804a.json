{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;\nconst util_1 = require(\"util\");\nconst zlib = require(\"zlib\");\nconst constants_1 = require(\"../../constants\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\n/** @public */\nexports.Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n});\nexports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);\nconst ZSTD_COMPRESSION_LEVEL = 3;\nconst zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));\nconst zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib));\nlet zstd;\nlet Snappy = null;\nfunction loadSnappy() {\n  if (Snappy == null) {\n    const snappyImport = (0, deps_1.getSnappy)();\n    if ('kModuleError' in snappyImport) {\n      throw snappyImport.kModuleError;\n    }\n    Snappy = snappyImport;\n  }\n  return Snappy;\n}\n// Facilitate compressing a message using an agreed compressor\nasync function compress(options, dataToBeCompressed) {\n  const zlibOptions = {};\n  switch (options.agreedCompressor) {\n    case 'snappy':\n      {\n        Snappy ?? (Snappy = loadSnappy());\n        return Snappy.compress(dataToBeCompressed);\n      }\n    case 'zstd':\n      {\n        loadZstd();\n        if ('kModuleError' in zstd) {\n          throw zstd['kModuleError'];\n        }\n        return zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);\n      }\n    case 'zlib':\n      {\n        if (options.zlibCompressionLevel) {\n          zlibOptions.level = options.zlibCompressionLevel;\n        }\n        return zlibDeflate(dataToBeCompressed, zlibOptions);\n      }\n    default:\n      {\n        throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);\n      }\n  }\n}\nexports.compress = compress;\n// Decompress a message using the given compressor\nasync function decompress(compressorID, compressedData) {\n  if (compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none) {\n    throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);\n  }\n  switch (compressorID) {\n    case exports.Compressor.snappy:\n      {\n        Snappy ?? (Snappy = loadSnappy());\n        return Snappy.uncompress(compressedData, {\n          asBuffer: true\n        });\n      }\n    case exports.Compressor.zstd:\n      {\n        loadZstd();\n        if ('kModuleError' in zstd) {\n          throw zstd['kModuleError'];\n        }\n        return zstd.decompress(compressedData);\n      }\n    case exports.Compressor.zlib:\n      {\n        return zlibInflate(compressedData);\n      }\n    default:\n      {\n        return compressedData;\n      }\n  }\n}\nexports.decompress = decompress;\n/**\r\n * Load ZStandard if it is not already set.\r\n */\nfunction loadZstd() {\n  if (!zstd) {\n    zstd = (0, deps_1.getZstdLibrary)();\n  }\n}","map":{"version":3,"mappings":"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","names":["exports","Object","freeze","none","snappy","zlib","zstd","Set","constants_1","ZSTD_COMPRESSION_LEVEL","zlibInflate","inflate","bind","zlibDeflate","deflate","Snappy","loadSnappy","snappyImport","kModuleError","compress","options","dataToBeCompressed","zlibOptions","agreedCompressor","loadZstd","zlibCompressionLevel","level","error_1","decompress","compressorID","compressedData","uncompress","asBuffer"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\compression.ts"],"sourcesContent":["import { promisify } from 'util';\r\nimport * as zlib from 'zlib';\r\n\r\nimport { LEGACY_HELLO_COMMAND } from '../../constants';\r\nimport { getSnappy, getZstdLibrary, type SnappyLib, type ZStandard } from '../../deps';\r\nimport { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';\r\n\r\n/** @public */\r\nexport const Compressor = Object.freeze({\r\n  none: 0,\r\n  snappy: 1,\r\n  zlib: 2,\r\n  zstd: 3\r\n} as const);\r\n\r\n/** @public */\r\nexport type Compressor = (typeof Compressor)[CompressorName];\r\n\r\n/** @public */\r\nexport type CompressorName = keyof typeof Compressor;\r\n\r\nexport const uncompressibleCommands = new Set([\r\n  LEGACY_HELLO_COMMAND,\r\n  'saslStart',\r\n  'saslContinue',\r\n  'getnonce',\r\n  'authenticate',\r\n  'createUser',\r\n  'updateUser',\r\n  'copydbSaslStart',\r\n  'copydbgetnonce',\r\n  'copydb'\r\n]);\r\n\r\nconst ZSTD_COMPRESSION_LEVEL = 3;\r\n\r\nconst zlibInflate = promisify(zlib.inflate.bind(zlib));\r\nconst zlibDeflate = promisify(zlib.deflate.bind(zlib));\r\n\r\nlet zstd: typeof ZStandard;\r\nlet Snappy: SnappyLib | null = null;\r\nfunction loadSnappy() {\r\n  if (Snappy == null) {\r\n    const snappyImport = getSnappy();\r\n    if ('kModuleError' in snappyImport) {\r\n      throw snappyImport.kModuleError;\r\n    }\r\n    Snappy = snappyImport;\r\n  }\r\n  return Snappy;\r\n}\r\n\r\n// Facilitate compressing a message using an agreed compressor\r\nexport async function compress(\r\n  options: { zlibCompressionLevel: number; agreedCompressor: CompressorName },\r\n  dataToBeCompressed: Buffer\r\n): Promise<Buffer> {\r\n  const zlibOptions = {} as zlib.ZlibOptions;\r\n  switch (options.agreedCompressor) {\r\n    case 'snappy': {\r\n      Snappy ??= loadSnappy();\r\n      return Snappy.compress(dataToBeCompressed);\r\n    }\r\n    case 'zstd': {\r\n      loadZstd();\r\n      if ('kModuleError' in zstd) {\r\n        throw zstd['kModuleError'];\r\n      }\r\n      return zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);\r\n    }\r\n    case 'zlib': {\r\n      if (options.zlibCompressionLevel) {\r\n        zlibOptions.level = options.zlibCompressionLevel;\r\n      }\r\n      return zlibDeflate(dataToBeCompressed, zlibOptions);\r\n    }\r\n    default: {\r\n      throw new MongoInvalidArgumentError(\r\n        `Unknown compressor ${options.agreedCompressor} failed to compress`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n// Decompress a message using the given compressor\r\nexport async function decompress(compressorID: number, compressedData: Buffer): Promise<Buffer> {\r\n  if (\r\n    compressorID !== Compressor.snappy &&\r\n    compressorID !== Compressor.zstd &&\r\n    compressorID !== Compressor.zlib &&\r\n    compressorID !== Compressor.none\r\n  ) {\r\n    throw new MongoDecompressionError(\r\n      `Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`\r\n    );\r\n  }\r\n\r\n  switch (compressorID) {\r\n    case Compressor.snappy: {\r\n      Snappy ??= loadSnappy();\r\n      return Snappy.uncompress(compressedData, { asBuffer: true });\r\n    }\r\n    case Compressor.zstd: {\r\n      loadZstd();\r\n      if ('kModuleError' in zstd) {\r\n        throw zstd['kModuleError'];\r\n      }\r\n      return zstd.decompress(compressedData);\r\n    }\r\n    case Compressor.zlib: {\r\n      return zlibInflate(compressedData);\r\n    }\r\n    default: {\r\n      return compressedData;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Load ZStandard if it is not already set.\r\n */\r\nfunction loadZstd() {\r\n  if (!zstd) {\r\n    zstd = getZstdLibrary();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}