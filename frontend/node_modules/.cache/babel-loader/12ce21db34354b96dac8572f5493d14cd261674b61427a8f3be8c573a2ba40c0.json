{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\nconst bson_1 = require(\"./bson\");\nconst ordered_1 = require(\"./bulk/ordered\");\nconst unordered_1 = require(\"./bulk/unordered\");\nconst change_stream_1 = require(\"./change_stream\");\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\nconst list_indexes_cursor_1 = require(\"./cursor/list_indexes_cursor\");\nconst list_search_indexes_cursor_1 = require(\"./cursor/list_search_indexes_cursor\");\nconst error_1 = require(\"./error\");\nconst bulk_write_1 = require(\"./operations/bulk_write\");\nconst count_1 = require(\"./operations/count\");\nconst count_documents_1 = require(\"./operations/count_documents\");\nconst delete_1 = require(\"./operations/delete\");\nconst distinct_1 = require(\"./operations/distinct\");\nconst drop_1 = require(\"./operations/drop\");\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\nconst indexes_1 = require(\"./operations/indexes\");\nconst insert_1 = require(\"./operations/insert\");\nconst is_capped_1 = require(\"./operations/is_capped\");\nconst options_operation_1 = require(\"./operations/options_operation\");\nconst rename_1 = require(\"./operations/rename\");\nconst create_1 = require(\"./operations/search_indexes/create\");\nconst drop_2 = require(\"./operations/search_indexes/drop\");\nconst update_1 = require(\"./operations/search_indexes/update\");\nconst stats_1 = require(\"./operations/stats\");\nconst update_2 = require(\"./operations/update\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst utils_1 = require(\"./utils\");\nconst write_concern_1 = require(\"./write_concern\");\n/**\r\n * The **Collection** class is an internal class that embodies a MongoDB collection\r\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\r\n *\r\n * **COLLECTION Cannot directly be instantiated**\r\n * @public\r\n *\r\n * @example\r\n * ```ts\r\n * import { MongoClient } from 'mongodb';\r\n *\r\n * interface Pet {\r\n *   name: string;\r\n *   kind: 'dog' | 'cat' | 'fish';\r\n * }\r\n *\r\n * const client = new MongoClient('mongodb://localhost:27017');\r\n * const pets = client.db().collection<Pet>('pets');\r\n *\r\n * const petCursor = pets.find();\r\n *\r\n * for await (const pet of petCursor) {\r\n *   console.log(`${pet.name} is a ${pet.kind}!`);\r\n * }\r\n * ```\r\n */\nclass Collection {\n  /**\r\n   * Create a new Collection instance\r\n   * @internal\r\n   */\n  constructor(db, name, options) {\n    (0, utils_1.checkCollectionName)(name);\n    // Internal state\n    this.s = {\n      db,\n      options,\n      namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),\n      pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.client = db.client;\n  }\n  /**\r\n   * The name of the database this collection belongs to\r\n   */\n  get dbName() {\n    return this.s.namespace.db;\n  }\n  /**\r\n   * The name of this collection\r\n   */\n  get collectionName() {\n    return this.s.namespace.collection;\n  }\n  /**\r\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\r\n   */\n  get namespace() {\n    return this.fullNamespace.toString();\n  }\n  /**\r\n   *  @internal\r\n   *\r\n   * The `MongoDBNamespace` for the collection.\r\n   */\n  get fullNamespace() {\n    return this.s.namespace;\n  }\n  /**\r\n   * The current readConcern of the collection. If not explicitly defined for\r\n   * this collection, will be inherited from the parent DB\r\n   */\n  get readConcern() {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n    return this.s.readConcern;\n  }\n  /**\r\n   * The current readPreference of the collection. If not explicitly defined for\r\n   * this collection, will be inherited from the parent DB\r\n   */\n  get readPreference() {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n    return this.s.readPreference;\n  }\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  /**\r\n   * The current writeConcern of the collection. If not explicitly defined for\r\n   * this collection, will be inherited from the parent DB\r\n   */\n  get writeConcern() {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n    return this.s.writeConcern;\n  }\n  /** The current index hint for the collection */\n  get hint() {\n    return this.s.collectionHint;\n  }\n  set hint(v) {\n    this.s.collectionHint = (0, utils_1.normalizeHintField)(v);\n  }\n  /**\r\n   * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\r\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\r\n   * can be overridden by setting the **forceServerObjectId** flag.\r\n   *\r\n   * @param doc - The document to insert\r\n   * @param options - Optional settings for the command\r\n   */\n  async insertOne(doc, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\r\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\r\n   * can be overridden by setting the **forceServerObjectId** flag.\r\n   *\r\n   * @param docs - The documents to insert\r\n   * @param options - Optional settings for the command\r\n   */\n  async insertMany(docs, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? {\n      ordered: true\n    })));\n  }\n  /**\r\n   * Perform a bulkWrite operation without a fluent API\r\n   *\r\n   * Legal operation types are\r\n   * - `insertOne`\r\n   * - `replaceOne`\r\n   * - `updateOne`\r\n   * - `updateMany`\r\n   * - `deleteOne`\r\n   * - `deleteMany`\r\n   *\r\n   * If documents passed in do not contain the **_id** field,\r\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\r\n   * can be overridden by setting the **forceServerObjectId** flag.\r\n   *\r\n   * @param operations - Bulk operations to perform\r\n   * @param options - Optional settings for the command\r\n   * @throws MongoDriverError if operations is not an array\r\n   */\n  async bulkWrite(operations, options) {\n    if (!Array.isArray(operations)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n    return (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? {\n      ordered: true\n    })));\n  }\n  /**\r\n   * Update a single document in a collection\r\n   *\r\n   * @param filter - The filter used to select the document to update\r\n   * @param update - The update operations to be applied to the document\r\n   * @param options - Optional settings for the command\r\n   */\n  async updateOne(filter, update, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Replace a document in a collection with another document\r\n   *\r\n   * @param filter - The filter used to select the document to replace\r\n   * @param replacement - The Document that replaces the matching document\r\n   * @param options - Optional settings for the command\r\n   */\n  async replaceOne(filter, replacement, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Update multiple documents in a collection\r\n   *\r\n   * @param filter - The filter used to select the documents to update\r\n   * @param update - The update operations to be applied to the documents\r\n   * @param options - Optional settings for the command\r\n   */\n  async updateMany(filter, update, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Delete a document from a collection\r\n   *\r\n   * @param filter - The filter used to select the document to remove\r\n   * @param options - Optional settings for the command\r\n   */\n  async deleteOne(filter = {}, options = {}) {\n    return (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Delete multiple documents from a collection\r\n   *\r\n   * @param filter - The filter used to select the documents to remove\r\n   * @param options - Optional settings for the command\r\n   */\n  async deleteMany(filter = {}, options = {}) {\n    return (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Rename the collection.\r\n   *\r\n   * @remarks\r\n   * This operation does not inherit options from the Db or MongoClient.\r\n   *\r\n   * @param newName - New name of of the collection.\r\n   * @param options - Optional settings for the command\r\n   */\n  async rename(newName, options) {\n    // Intentionally, we do not inherit options from parent for this operation.\n    return (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, {\n      ...options,\n      readPreference: read_preference_1.ReadPreference.PRIMARY\n    }));\n  }\n  /**\r\n   * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\n  async drop(options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options));\n  }\n  async findOne(filter = {}, options = {}) {\n    return this.find(filter, options).limit(-1).batchSize(1).next();\n  }\n  find(filter = {}, options = {}) {\n    return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\r\n   * Returns the options of the collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\n  async options(options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Returns if the collection is a capped collection\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\n  async isCapped(options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Creates an index on the db and collection collection.\r\n   *\r\n   * @param indexSpec - The field name or index specification to create an index for\r\n   * @param options - Optional settings for the command\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * const collection = client.db('foo').collection('bar');\r\n   *\r\n   * await collection.createIndex({ a: 1, b: -1 });\r\n   *\r\n   * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\r\n   * await collection.createIndex([ [c, 1], [d, -1] ]);\r\n   *\r\n   * // Equivalent to { e: 1 }\r\n   * await collection.createIndex('e');\r\n   *\r\n   * // Equivalent to { f: 1, g: 1 }\r\n   * await collection.createIndex(['f', 'g'])\r\n   *\r\n   * // Equivalent to { h: 1, i: -1 }\r\n   * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\r\n   *\r\n   * // Equivalent to { j: 1, k: -1, l: 2d }\r\n   * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\r\n   * ```\r\n   */\n  async createIndex(indexSpec, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Creates multiple indexes in the collection, this method is only supported for\r\n   * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\r\n   * error.\r\n   *\r\n   * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\r\n   * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.\r\n   *\r\n   * @param indexSpecs - An array of index specifications to be created\r\n   * @param options - Optional settings for the command\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * const collection = client.db('foo').collection('bar');\r\n   * await collection.createIndexes([\r\n   *   // Simple index on field fizz\r\n   *   {\r\n   *     key: { fizz: 1 },\r\n   *   }\r\n   *   // wildcard index\r\n   *   {\r\n   *     key: { '$**': 1 }\r\n   *   },\r\n   *   // named index on darmok and jalad\r\n   *   {\r\n   *     key: { darmok: 1, jalad: -1 }\r\n   *     name: 'tanagra'\r\n   *   }\r\n   * ]);\r\n   * ```\r\n   */\n  async createIndexes(indexSpecs, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, {\n      ...options,\n      maxTimeMS: undefined\n    })));\n  }\n  /**\r\n   * Drops an index from this collection.\r\n   *\r\n   * @param indexName - Name of the index to drop.\r\n   * @param options - Optional settings for the command\r\n   */\n  async dropIndex(indexName, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, {\n      ...(0, utils_1.resolveOptions)(this, options),\n      readPreference: read_preference_1.ReadPreference.primary\n    }));\n  }\n  /**\r\n   * Drops all indexes from this collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\n  async dropIndexes(options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Get the list of all indexes information for the collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\n  listIndexes(options) {\n    return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\r\n   * Checks if one or more indexes exist on the collection, fails on first non-existing index\r\n   *\r\n   * @param indexes - One or more index names to check.\r\n   * @param options - Optional settings for the command\r\n   */\n  async indexExists(indexes, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Retrieves this collections index info.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\n  async indexInformation(options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Gets an estimate of the count of documents in a collection using collection metadata.\r\n   * This will always run a count command on all server versions.\r\n   *\r\n   * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\r\n   * which estimatedDocumentCount uses in its implementation, was not included in v1 of\r\n   * the Stable API, and so users of the Stable API with estimatedDocumentCount are\r\n   * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\r\n   * encountering errors.\r\n   *\r\n   * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\r\n   * @param options - Optional settings for the command\r\n   */\n  async estimatedDocumentCount(options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Gets the number of documents matching the filter.\r\n   * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\r\n   * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\r\n   * the following query operators must be replaced:\r\n   *\r\n   * | Operator | Replacement |\r\n   * | -------- | ----------- |\r\n   * | `$where`   | [`$expr`][1] |\r\n   * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\r\n   * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\r\n   *\r\n   * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/\r\n   * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\r\n   * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\r\n   * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\r\n   *\r\n   * @param filter - The filter for the count\r\n   * @param options - Optional settings for the command\r\n   *\r\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/\r\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\r\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\r\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\r\n   */\n  async countDocuments(filter = {}, options = {}) {\n    return (0, execute_operation_1.executeOperation)(this.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  async distinct(key, filter = {}, options = {}) {\n    return (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Retrieve all the indexes on the collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\n  async indexes(options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Get all the collection statistics.\r\n   *\r\n   * @deprecated the `collStats` operation will be removed in the next major release.  Please\r\n   * use an aggregation pipeline with the [`$collStats`](https://www.mongodb.com/docs/manual/reference/operator/aggregation/collStats/) stage instead\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\n  async stats(options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new stats_1.CollStatsOperation(this, options));\n  }\n  async findOneAndDelete(filter, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  async findOneAndReplace(filter, replacement, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));\n  }\n  async findOneAndUpdate(filter, update, options) {\n    return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));\n  }\n  /**\r\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\r\n   *\r\n   * @param pipeline - An array of aggregation pipelines to execute\r\n   * @param options - Optional settings for the command\r\n   */\n  aggregate(pipeline = [], options) {\n    if (!Array.isArray(pipeline)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n    }\n    return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\r\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\r\n   *\r\n   * @remarks\r\n   * watch() accepts two generic arguments for distinct use cases:\r\n   * - The first is to override the schema that may be defined for this specific collection\r\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\r\n   * @example\r\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\r\n   * ```ts\r\n   * collection.watch<{ _id: number }>()\r\n   *   .on('change', change => console.log(change._id.toFixed(4)));\r\n   * ```\r\n   *\r\n   * @example\r\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\r\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\r\n   * No need start from scratch on the ChangeStreamInsertDocument type!\r\n   * By using an intersection we can save time and ensure defaults remain the same type!\r\n   * ```ts\r\n   * collection\r\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\r\n   *     { $addFields: { comment: 'big changes' } },\r\n   *     { $match: { operationType: 'insert' } }\r\n   *   ])\r\n   *   .on('change', change => {\r\n   *     change.comment.startsWith('big');\r\n   *     change.operationType === 'insert';\r\n   *     // No need to narrow in code because the generics did that for us!\r\n   *     expectType<Schema>(change.fullDocument);\r\n   *   });\r\n   * ```\r\n   *\r\n   * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\r\n   * @param options - Optional settings for the command\r\n   * @typeParam TLocal - Type of the data being detected by the change stream\r\n   * @typeParam TChange - Type of the whole change stream document emitted\r\n   */\n  watch(pipeline = [], options = {}) {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\r\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\r\n   *\r\n   * @throws MongoNotConnectedError\r\n   * @remarks\r\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\r\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\r\n   */\n  initializeUnorderedBulkOp(options) {\n    return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\r\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\r\n   *\r\n   * @throws MongoNotConnectedError\r\n   * @remarks\r\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\r\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\r\n   */\n  initializeOrderedBulkOp(options) {\n    return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\r\n   * An estimated count of matching documents in the db to a filter.\r\n   *\r\n   * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\r\n   * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\r\n   * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\r\n   *\r\n   * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\r\n   *\r\n   * @param filter - The filter for the count.\r\n   * @param options - Optional settings for the command\r\n   */\n  async count(filter = {}, options = {}) {\n    return (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options)));\n  }\n  listSearchIndexes(indexNameOrOptions, options) {\n    options = typeof indexNameOrOptions === 'object' ? indexNameOrOptions : options == null ? {} : options;\n    const indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === 'object' ? null : indexNameOrOptions;\n    return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);\n  }\n  /**\r\n   * Creates a single search index for the collection.\r\n   *\r\n   * @param description - The index description for the new search index.\r\n   * @returns A promise that resolves to the name of the new search index.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   */\n  async createSearchIndex(description) {\n    const [index] = await this.createSearchIndexes([description]);\n    return index;\n  }\n  /**\r\n   * Creates multiple search indexes for the current collection.\r\n   *\r\n   * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.\r\n   * @returns A promise that resolves to an array of the newly created search index names.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   * @returns\r\n   */\n  async createSearchIndexes(descriptions) {\n    return (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions));\n  }\n  /**\r\n   * Deletes a search index by index name.\r\n   *\r\n   * @param name - The name of the search index to be deleted.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   */\n  async dropSearchIndex(name) {\n    return (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name));\n  }\n  /**\r\n   * Updates a search index by replacing the existing index definition with the provided definition.\r\n   *\r\n   * @param name - The name of the search index to update.\r\n   * @param definition - The new search index definition.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   */\n  async updateSearchIndex(name, definition) {\n    return (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition));\n  }\n}\nexports.Collection = Collection;","map":{"version":3,"mappings":"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","names":["Collection","constructor","db","name","options","s","namespace","utils_1","databaseName","pkFactory","readPreference","read_preference_1","fromOptions","bsonOptions","readConcern","read_concern_1","writeConcern","write_concern_1","client","dbName","collectionName","collection","fullNamespace","toString","hint","collectionHint","v","insertOne","doc","insert_1","insertMany","docs","ordered","bulkWrite","operations","Array","isArray","error_1","bulk_write_1","updateOne","filter","update","update_2","replaceOne","replacement","updateMany","deleteOne","delete_1","deleteMany","rename","newName","rename_1","PRIMARY","drop","drop_1","findOne","find","limit","batchSize","next","find_cursor_1","options_operation_1","isCapped","is_capped_1","createIndex","indexSpec","indexes_1","createIndexes","indexSpecs","maxTimeMS","undefined","dropIndex","indexName","primary","dropIndexes","listIndexes","list_indexes_cursor_1","indexExists","indexes","indexInformation","estimatedDocumentCount","estimated_document_count_1","countDocuments","count_documents_1","distinct","key","distinct_1","stats","stats_1","findOneAndDelete","find_and_modify_1","findOneAndReplace","findOneAndUpdate","aggregate","pipeline","aggregation_cursor_1","watch","change_stream_1","initializeUnorderedBulkOp","unordered_1","initializeOrderedBulkOp","ordered_1","count","count_1","listSearchIndexes","indexNameOrOptions","list_search_indexes_cursor_1","createSearchIndex","description","index","createSearchIndexes","descriptions","create_1","dropSearchIndex","drop_2","updateSearchIndex","definition","update_1","exports"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\collection.ts"],"sourcesContent":["import { type BSONSerializeOptions, type Document, resolveBSONOptions } from './bson';\r\nimport type { AnyBulkWriteOperation, BulkWriteOptions, BulkWriteResult } from './bulk/common';\r\nimport { OrderedBulkOperation } from './bulk/ordered';\r\nimport { UnorderedBulkOperation } from './bulk/unordered';\r\nimport { ChangeStream, type ChangeStreamDocument, type ChangeStreamOptions } from './change_stream';\r\nimport { AggregationCursor } from './cursor/aggregation_cursor';\r\nimport { FindCursor } from './cursor/find_cursor';\r\nimport { ListIndexesCursor } from './cursor/list_indexes_cursor';\r\nimport {\r\n  ListSearchIndexesCursor,\r\n  type ListSearchIndexesOptions\r\n} from './cursor/list_search_indexes_cursor';\r\nimport type { Db } from './db';\r\nimport { MongoInvalidArgumentError } from './error';\r\nimport type { MongoClient, PkFactory } from './mongo_client';\r\nimport type {\r\n  Filter,\r\n  Flatten,\r\n  OptionalUnlessRequiredId,\r\n  TODO_NODE_3286,\r\n  UpdateFilter,\r\n  WithId,\r\n  WithoutId\r\n} from './mongo_types';\r\nimport type { AggregateOptions } from './operations/aggregate';\r\nimport { BulkWriteOperation } from './operations/bulk_write';\r\nimport type { IndexInformationOptions } from './operations/common_functions';\r\nimport { CountOperation, type CountOptions } from './operations/count';\r\nimport { CountDocumentsOperation, type CountDocumentsOptions } from './operations/count_documents';\r\nimport {\r\n  DeleteManyOperation,\r\n  DeleteOneOperation,\r\n  type DeleteOptions,\r\n  type DeleteResult\r\n} from './operations/delete';\r\nimport { DistinctOperation, type DistinctOptions } from './operations/distinct';\r\nimport { DropCollectionOperation, type DropCollectionOptions } from './operations/drop';\r\nimport {\r\n  EstimatedDocumentCountOperation,\r\n  type EstimatedDocumentCountOptions\r\n} from './operations/estimated_document_count';\r\nimport { executeOperation } from './operations/execute_operation';\r\nimport type { FindOptions } from './operations/find';\r\nimport {\r\n  FindOneAndDeleteOperation,\r\n  type FindOneAndDeleteOptions,\r\n  FindOneAndReplaceOperation,\r\n  type FindOneAndReplaceOptions,\r\n  FindOneAndUpdateOperation,\r\n  type FindOneAndUpdateOptions\r\n} from './operations/find_and_modify';\r\nimport {\r\n  CreateIndexesOperation,\r\n  type CreateIndexesOptions,\r\n  CreateIndexOperation,\r\n  DropIndexesOperation,\r\n  type DropIndexesOptions,\r\n  DropIndexOperation,\r\n  type IndexDescription,\r\n  IndexesOperation,\r\n  IndexExistsOperation,\r\n  IndexInformationOperation,\r\n  type IndexSpecification,\r\n  type ListIndexesOptions\r\n} from './operations/indexes';\r\nimport {\r\n  InsertManyOperation,\r\n  type InsertManyResult,\r\n  InsertOneOperation,\r\n  type InsertOneOptions,\r\n  type InsertOneResult\r\n} from './operations/insert';\r\nimport { IsCappedOperation } from './operations/is_capped';\r\nimport type { Hint, OperationOptions } from './operations/operation';\r\nimport { OptionsOperation } from './operations/options_operation';\r\nimport { RenameOperation, type RenameOptions } from './operations/rename';\r\nimport {\r\n  CreateSearchIndexesOperation,\r\n  type SearchIndexDescription\r\n} from './operations/search_indexes/create';\r\nimport { DropSearchIndexOperation } from './operations/search_indexes/drop';\r\nimport { UpdateSearchIndexOperation } from './operations/search_indexes/update';\r\nimport { type CollStats, CollStatsOperation, type CollStatsOptions } from './operations/stats';\r\nimport {\r\n  ReplaceOneOperation,\r\n  type ReplaceOptions,\r\n  UpdateManyOperation,\r\n  UpdateOneOperation,\r\n  type UpdateOptions,\r\n  type UpdateResult\r\n} from './operations/update';\r\nimport { ReadConcern, type ReadConcernLike } from './read_concern';\r\nimport { ReadPreference, type ReadPreferenceLike } from './read_preference';\r\nimport {\r\n  checkCollectionName,\r\n  DEFAULT_PK_FACTORY,\r\n  MongoDBCollectionNamespace,\r\n  normalizeHintField,\r\n  resolveOptions\r\n} from './utils';\r\nimport { WriteConcern, type WriteConcernOptions } from './write_concern';\r\n\r\n/** @public */\r\nexport interface ModifyResult<TSchema = Document> {\r\n  value: WithId<TSchema> | null;\r\n  lastErrorObject?: Document;\r\n  ok: 0 | 1;\r\n}\r\n\r\n/** @public */\r\nexport interface CollectionOptions extends BSONSerializeOptions, WriteConcernOptions {\r\n  /** Specify a read concern for the collection. (only MongoDB 3.2 or higher supported) */\r\n  readConcern?: ReadConcernLike;\r\n  /** The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST). */\r\n  readPreference?: ReadPreferenceLike;\r\n}\r\n\r\n/** @internal */\r\nexport interface CollectionPrivate {\r\n  pkFactory: PkFactory;\r\n  db: Db;\r\n  options: any;\r\n  namespace: MongoDBCollectionNamespace;\r\n  readPreference?: ReadPreference;\r\n  bsonOptions: BSONSerializeOptions;\r\n  collectionHint?: Hint;\r\n  readConcern?: ReadConcern;\r\n  writeConcern?: WriteConcern;\r\n}\r\n\r\n/**\r\n * The **Collection** class is an internal class that embodies a MongoDB collection\r\n * allowing for insert/find/update/delete and other command operation on that MongoDB collection.\r\n *\r\n * **COLLECTION Cannot directly be instantiated**\r\n * @public\r\n *\r\n * @example\r\n * ```ts\r\n * import { MongoClient } from 'mongodb';\r\n *\r\n * interface Pet {\r\n *   name: string;\r\n *   kind: 'dog' | 'cat' | 'fish';\r\n * }\r\n *\r\n * const client = new MongoClient('mongodb://localhost:27017');\r\n * const pets = client.db().collection<Pet>('pets');\r\n *\r\n * const petCursor = pets.find();\r\n *\r\n * for await (const pet of petCursor) {\r\n *   console.log(`${pet.name} is a ${pet.kind}!`);\r\n * }\r\n * ```\r\n */\r\nexport class Collection<TSchema extends Document = Document> {\r\n  /** @internal */\r\n  s: CollectionPrivate;\r\n\r\n  /** @internal */\r\n  client: MongoClient;\r\n\r\n  /**\r\n   * Create a new Collection instance\r\n   * @internal\r\n   */\r\n  constructor(db: Db, name: string, options?: CollectionOptions) {\r\n    checkCollectionName(name);\r\n\r\n    // Internal state\r\n    this.s = {\r\n      db,\r\n      options,\r\n      namespace: new MongoDBCollectionNamespace(db.databaseName, name),\r\n      pkFactory: db.options?.pkFactory ?? DEFAULT_PK_FACTORY,\r\n      readPreference: ReadPreference.fromOptions(options),\r\n      bsonOptions: resolveBSONOptions(options, db),\r\n      readConcern: ReadConcern.fromOptions(options),\r\n      writeConcern: WriteConcern.fromOptions(options)\r\n    };\r\n\r\n    this.client = db.client;\r\n  }\r\n\r\n  /**\r\n   * The name of the database this collection belongs to\r\n   */\r\n  get dbName(): string {\r\n    return this.s.namespace.db;\r\n  }\r\n\r\n  /**\r\n   * The name of this collection\r\n   */\r\n  get collectionName(): string {\r\n    return this.s.namespace.collection;\r\n  }\r\n\r\n  /**\r\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\r\n   */\r\n  get namespace(): string {\r\n    return this.fullNamespace.toString();\r\n  }\r\n\r\n  /**\r\n   *  @internal\r\n   *\r\n   * The `MongoDBNamespace` for the collection.\r\n   */\r\n  get fullNamespace(): MongoDBCollectionNamespace {\r\n    return this.s.namespace;\r\n  }\r\n\r\n  /**\r\n   * The current readConcern of the collection. If not explicitly defined for\r\n   * this collection, will be inherited from the parent DB\r\n   */\r\n  get readConcern(): ReadConcern | undefined {\r\n    if (this.s.readConcern == null) {\r\n      return this.s.db.readConcern;\r\n    }\r\n    return this.s.readConcern;\r\n  }\r\n\r\n  /**\r\n   * The current readPreference of the collection. If not explicitly defined for\r\n   * this collection, will be inherited from the parent DB\r\n   */\r\n  get readPreference(): ReadPreference | undefined {\r\n    if (this.s.readPreference == null) {\r\n      return this.s.db.readPreference;\r\n    }\r\n\r\n    return this.s.readPreference;\r\n  }\r\n\r\n  get bsonOptions(): BSONSerializeOptions {\r\n    return this.s.bsonOptions;\r\n  }\r\n\r\n  /**\r\n   * The current writeConcern of the collection. If not explicitly defined for\r\n   * this collection, will be inherited from the parent DB\r\n   */\r\n  get writeConcern(): WriteConcern | undefined {\r\n    if (this.s.writeConcern == null) {\r\n      return this.s.db.writeConcern;\r\n    }\r\n    return this.s.writeConcern;\r\n  }\r\n\r\n  /** The current index hint for the collection */\r\n  get hint(): Hint | undefined {\r\n    return this.s.collectionHint;\r\n  }\r\n\r\n  set hint(v: Hint | undefined) {\r\n    this.s.collectionHint = normalizeHintField(v);\r\n  }\r\n\r\n  /**\r\n   * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\r\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\r\n   * can be overridden by setting the **forceServerObjectId** flag.\r\n   *\r\n   * @param doc - The document to insert\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async insertOne(\r\n    doc: OptionalUnlessRequiredId<TSchema>,\r\n    options?: InsertOneOptions\r\n  ): Promise<InsertOneResult<TSchema>> {\r\n    return executeOperation(\r\n      this.client,\r\n      new InsertOneOperation(\r\n        this as TODO_NODE_3286,\r\n        doc,\r\n        resolveOptions(this, options)\r\n      ) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\r\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\r\n   * can be overridden by setting the **forceServerObjectId** flag.\r\n   *\r\n   * @param docs - The documents to insert\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async insertMany(\r\n    docs: OptionalUnlessRequiredId<TSchema>[],\r\n    options?: BulkWriteOptions\r\n  ): Promise<InsertManyResult<TSchema>> {\r\n    return executeOperation(\r\n      this.client,\r\n      new InsertManyOperation(\r\n        this as TODO_NODE_3286,\r\n        docs,\r\n        resolveOptions(this, options ?? { ordered: true })\r\n      ) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Perform a bulkWrite operation without a fluent API\r\n   *\r\n   * Legal operation types are\r\n   * - `insertOne`\r\n   * - `replaceOne`\r\n   * - `updateOne`\r\n   * - `updateMany`\r\n   * - `deleteOne`\r\n   * - `deleteMany`\r\n   *\r\n   * If documents passed in do not contain the **_id** field,\r\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\r\n   * can be overridden by setting the **forceServerObjectId** flag.\r\n   *\r\n   * @param operations - Bulk operations to perform\r\n   * @param options - Optional settings for the command\r\n   * @throws MongoDriverError if operations is not an array\r\n   */\r\n  async bulkWrite(\r\n    operations: AnyBulkWriteOperation<TSchema>[],\r\n    options?: BulkWriteOptions\r\n  ): Promise<BulkWriteResult> {\r\n    if (!Array.isArray(operations)) {\r\n      throw new MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\r\n    }\r\n\r\n    return executeOperation(\r\n      this.client,\r\n      new BulkWriteOperation(\r\n        this as TODO_NODE_3286,\r\n        operations as TODO_NODE_3286,\r\n        resolveOptions(this, options ?? { ordered: true })\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update a single document in a collection\r\n   *\r\n   * @param filter - The filter used to select the document to update\r\n   * @param update - The update operations to be applied to the document\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async updateOne(\r\n    filter: Filter<TSchema>,\r\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\r\n    options?: UpdateOptions\r\n  ): Promise<UpdateResult<TSchema>> {\r\n    return executeOperation(\r\n      this.client,\r\n      new UpdateOneOperation(\r\n        this as TODO_NODE_3286,\r\n        filter,\r\n        update,\r\n        resolveOptions(this, options)\r\n      ) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Replace a document in a collection with another document\r\n   *\r\n   * @param filter - The filter used to select the document to replace\r\n   * @param replacement - The Document that replaces the matching document\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async replaceOne(\r\n    filter: Filter<TSchema>,\r\n    replacement: WithoutId<TSchema>,\r\n    options?: ReplaceOptions\r\n  ): Promise<UpdateResult<TSchema> | Document> {\r\n    return executeOperation(\r\n      this.client,\r\n      new ReplaceOneOperation(\r\n        this as TODO_NODE_3286,\r\n        filter,\r\n        replacement,\r\n        resolveOptions(this, options)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update multiple documents in a collection\r\n   *\r\n   * @param filter - The filter used to select the documents to update\r\n   * @param update - The update operations to be applied to the documents\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async updateMany(\r\n    filter: Filter<TSchema>,\r\n    update: UpdateFilter<TSchema>,\r\n    options?: UpdateOptions\r\n  ): Promise<UpdateResult<TSchema>> {\r\n    return executeOperation(\r\n      this.client,\r\n      new UpdateManyOperation(\r\n        this as TODO_NODE_3286,\r\n        filter,\r\n        update,\r\n        resolveOptions(this, options)\r\n      ) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Delete a document from a collection\r\n   *\r\n   * @param filter - The filter used to select the document to remove\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async deleteOne(\r\n    filter: Filter<TSchema> = {},\r\n    options: DeleteOptions = {}\r\n  ): Promise<DeleteResult> {\r\n    return executeOperation(\r\n      this.client,\r\n      new DeleteOneOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Delete multiple documents from a collection\r\n   *\r\n   * @param filter - The filter used to select the documents to remove\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async deleteMany(\r\n    filter: Filter<TSchema> = {},\r\n    options: DeleteOptions = {}\r\n  ): Promise<DeleteResult> {\r\n    return executeOperation(\r\n      this.client,\r\n      new DeleteManyOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Rename the collection.\r\n   *\r\n   * @remarks\r\n   * This operation does not inherit options from the Db or MongoClient.\r\n   *\r\n   * @param newName - New name of of the collection.\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async rename(newName: string, options?: RenameOptions): Promise<Collection> {\r\n    // Intentionally, we do not inherit options from parent for this operation.\r\n    return executeOperation(\r\n      this.client,\r\n      new RenameOperation(this as TODO_NODE_3286, newName, {\r\n        ...options,\r\n        readPreference: ReadPreference.PRIMARY\r\n      }) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async drop(options?: DropCollectionOptions): Promise<boolean> {\r\n    return executeOperation(\r\n      this.client,\r\n      new DropCollectionOperation(this.s.db, this.collectionName, options)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Fetches the first document that matches the filter\r\n   *\r\n   * @param filter - Query for find Operation\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async findOne(): Promise<WithId<TSchema> | null>;\r\n  async findOne(filter: Filter<TSchema>): Promise<WithId<TSchema> | null>;\r\n  async findOne(filter: Filter<TSchema>, options: FindOptions): Promise<WithId<TSchema> | null>;\r\n\r\n  // allow an override of the schema.\r\n  async findOne<T = TSchema>(): Promise<T | null>;\r\n  async findOne<T = TSchema>(filter: Filter<TSchema>): Promise<T | null>;\r\n  async findOne<T = TSchema>(filter: Filter<TSchema>, options?: FindOptions): Promise<T | null>;\r\n\r\n  async findOne(\r\n    filter: Filter<TSchema> = {},\r\n    options: FindOptions = {}\r\n  ): Promise<WithId<TSchema> | null> {\r\n    return this.find(filter, options).limit(-1).batchSize(1).next();\r\n  }\r\n\r\n  /**\r\n   * Creates a cursor for a filter that can be used to iterate over results from MongoDB\r\n   *\r\n   * @param filter - The filter predicate. If unspecified, then all documents in the collection will match the predicate\r\n   */\r\n  find(): FindCursor<WithId<TSchema>>;\r\n  find(filter: Filter<TSchema>, options?: FindOptions): FindCursor<WithId<TSchema>>;\r\n  find<T extends Document>(filter: Filter<TSchema>, options?: FindOptions): FindCursor<T>;\r\n  find(filter: Filter<TSchema> = {}, options: FindOptions = {}): FindCursor<WithId<TSchema>> {\r\n    return new FindCursor<WithId<TSchema>>(\r\n      this.client,\r\n      this.s.namespace,\r\n      filter,\r\n      resolveOptions(this as TODO_NODE_3286, options)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the options of the collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async options(options?: OperationOptions): Promise<Document> {\r\n    return executeOperation(\r\n      this.client,\r\n      new OptionsOperation(this as TODO_NODE_3286, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns if the collection is a capped collection\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async isCapped(options?: OperationOptions): Promise<boolean> {\r\n    return executeOperation(\r\n      this.client,\r\n      new IsCappedOperation(this as TODO_NODE_3286, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates an index on the db and collection collection.\r\n   *\r\n   * @param indexSpec - The field name or index specification to create an index for\r\n   * @param options - Optional settings for the command\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * const collection = client.db('foo').collection('bar');\r\n   *\r\n   * await collection.createIndex({ a: 1, b: -1 });\r\n   *\r\n   * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\r\n   * await collection.createIndex([ [c, 1], [d, -1] ]);\r\n   *\r\n   * // Equivalent to { e: 1 }\r\n   * await collection.createIndex('e');\r\n   *\r\n   * // Equivalent to { f: 1, g: 1 }\r\n   * await collection.createIndex(['f', 'g'])\r\n   *\r\n   * // Equivalent to { h: 1, i: -1 }\r\n   * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\r\n   *\r\n   * // Equivalent to { j: 1, k: -1, l: 2d }\r\n   * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\r\n   * ```\r\n   */\r\n  async createIndex(\r\n    indexSpec: IndexSpecification,\r\n    options?: CreateIndexesOptions\r\n  ): Promise<string> {\r\n    return executeOperation(\r\n      this.client,\r\n      new CreateIndexOperation(\r\n        this as TODO_NODE_3286,\r\n        this.collectionName,\r\n        indexSpec,\r\n        resolveOptions(this, options)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates multiple indexes in the collection, this method is only supported for\r\n   * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\r\n   * error.\r\n   *\r\n   * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\r\n   * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.\r\n   *\r\n   * @param indexSpecs - An array of index specifications to be created\r\n   * @param options - Optional settings for the command\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * const collection = client.db('foo').collection('bar');\r\n   * await collection.createIndexes([\r\n   *   // Simple index on field fizz\r\n   *   {\r\n   *     key: { fizz: 1 },\r\n   *   }\r\n   *   // wildcard index\r\n   *   {\r\n   *     key: { '$**': 1 }\r\n   *   },\r\n   *   // named index on darmok and jalad\r\n   *   {\r\n   *     key: { darmok: 1, jalad: -1 }\r\n   *     name: 'tanagra'\r\n   *   }\r\n   * ]);\r\n   * ```\r\n   */\r\n  async createIndexes(\r\n    indexSpecs: IndexDescription[],\r\n    options?: CreateIndexesOptions\r\n  ): Promise<string[]> {\r\n    return executeOperation(\r\n      this.client,\r\n      new CreateIndexesOperation(\r\n        this as TODO_NODE_3286,\r\n        this.collectionName,\r\n        indexSpecs,\r\n        resolveOptions(this, { ...options, maxTimeMS: undefined })\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Drops an index from this collection.\r\n   *\r\n   * @param indexName - Name of the index to drop.\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async dropIndex(indexName: string, options?: DropIndexesOptions): Promise<Document> {\r\n    return executeOperation(\r\n      this.client,\r\n      new DropIndexOperation(this as TODO_NODE_3286, indexName, {\r\n        ...resolveOptions(this, options),\r\n        readPreference: ReadPreference.primary\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Drops all indexes from this collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async dropIndexes(options?: DropIndexesOptions): Promise<Document> {\r\n    return executeOperation(\r\n      this.client,\r\n      new DropIndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the list of all indexes information for the collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\r\n  listIndexes(options?: ListIndexesOptions): ListIndexesCursor {\r\n    return new ListIndexesCursor(this as TODO_NODE_3286, resolveOptions(this, options));\r\n  }\r\n\r\n  /**\r\n   * Checks if one or more indexes exist on the collection, fails on first non-existing index\r\n   *\r\n   * @param indexes - One or more index names to check.\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async indexExists(\r\n    indexes: string | string[],\r\n    options?: IndexInformationOptions\r\n  ): Promise<boolean> {\r\n    return executeOperation(\r\n      this.client,\r\n      new IndexExistsOperation(this as TODO_NODE_3286, indexes, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retrieves this collections index info.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async indexInformation(options?: IndexInformationOptions): Promise<Document> {\r\n    return executeOperation(\r\n      this.client,\r\n      new IndexInformationOperation(this.s.db, this.collectionName, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets an estimate of the count of documents in a collection using collection metadata.\r\n   * This will always run a count command on all server versions.\r\n   *\r\n   * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,\r\n   * which estimatedDocumentCount uses in its implementation, was not included in v1 of\r\n   * the Stable API, and so users of the Stable API with estimatedDocumentCount are\r\n   * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid\r\n   * encountering errors.\r\n   *\r\n   * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async estimatedDocumentCount(options?: EstimatedDocumentCountOptions): Promise<number> {\r\n    return executeOperation(\r\n      this.client,\r\n      new EstimatedDocumentCountOperation(this as TODO_NODE_3286, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets the number of documents matching the filter.\r\n   * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\r\n   * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\r\n   * the following query operators must be replaced:\r\n   *\r\n   * | Operator | Replacement |\r\n   * | -------- | ----------- |\r\n   * | `$where`   | [`$expr`][1] |\r\n   * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\r\n   * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\r\n   *\r\n   * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/\r\n   * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\r\n   * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\r\n   * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\r\n   *\r\n   * @param filter - The filter for the count\r\n   * @param options - Optional settings for the command\r\n   *\r\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/\r\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\r\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center\r\n   * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere\r\n   */\r\n  async countDocuments(\r\n    filter: Document = {},\r\n    options: CountDocumentsOptions = {}\r\n  ): Promise<number> {\r\n    return executeOperation(\r\n      this.client,\r\n      new CountDocumentsOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * The distinct command returns a list of distinct values for the given key across a collection.\r\n   *\r\n   * @param key - Field of the document to find distinct values for\r\n   * @param filter - The filter for filtering the set of documents to which we apply the distinct filter.\r\n   * @param options - Optional settings for the command\r\n   */\r\n  distinct<Key extends keyof WithId<TSchema>>(\r\n    key: Key\r\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\r\n  distinct<Key extends keyof WithId<TSchema>>(\r\n    key: Key,\r\n    filter: Filter<TSchema>\r\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\r\n  distinct<Key extends keyof WithId<TSchema>>(\r\n    key: Key,\r\n    filter: Filter<TSchema>,\r\n    options: DistinctOptions\r\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\r\n\r\n  // Embedded documents overload\r\n  distinct(key: string): Promise<any[]>;\r\n  distinct(key: string, filter: Filter<TSchema>): Promise<any[]>;\r\n  distinct(key: string, filter: Filter<TSchema>, options: DistinctOptions): Promise<any[]>;\r\n\r\n  async distinct<Key extends keyof WithId<TSchema>>(\r\n    key: Key,\r\n    filter: Filter<TSchema> = {},\r\n    options: DistinctOptions = {}\r\n  ): Promise<any[]> {\r\n    return executeOperation(\r\n      this.client,\r\n      new DistinctOperation(\r\n        this as TODO_NODE_3286,\r\n        key as TODO_NODE_3286,\r\n        filter,\r\n        resolveOptions(this, options)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Retrieve all the indexes on the collection.\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async indexes(options?: IndexInformationOptions): Promise<Document[]> {\r\n    return executeOperation(\r\n      this.client,\r\n      new IndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get all the collection statistics.\r\n   *\r\n   * @deprecated the `collStats` operation will be removed in the next major release.  Please\r\n   * use an aggregation pipeline with the [`$collStats`](https://www.mongodb.com/docs/manual/reference/operator/aggregation/collStats/) stage instead\r\n   *\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async stats(options?: CollStatsOptions): Promise<CollStats> {\r\n    return executeOperation(\r\n      this.client,\r\n      new CollStatsOperation(this as TODO_NODE_3286, options) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\r\n   *\r\n   * @param filter - The filter used to select the document to remove\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async findOneAndDelete(\r\n    filter: Filter<TSchema>,\r\n    options: FindOneAndDeleteOptions & { includeResultMetadata: true }\r\n  ): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndDelete(\r\n    filter: Filter<TSchema>,\r\n    options: FindOneAndDeleteOptions & { includeResultMetadata: false }\r\n  ): Promise<WithId<TSchema> | null>;\r\n  async findOneAndDelete(\r\n    filter: Filter<TSchema>,\r\n    options: FindOneAndDeleteOptions\r\n  ): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndDelete(filter: Filter<TSchema>): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndDelete(\r\n    filter: Filter<TSchema>,\r\n    options?: FindOneAndDeleteOptions\r\n  ): Promise<WithId<TSchema> | ModifyResult<TSchema> | null> {\r\n    return executeOperation(\r\n      this.client,\r\n      new FindOneAndDeleteOperation(\r\n        this as TODO_NODE_3286,\r\n        filter,\r\n        resolveOptions(this, options)\r\n      ) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\r\n   *\r\n   * @param filter - The filter used to select the document to replace\r\n   * @param replacement - The Document that replaces the matching document\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async findOneAndReplace(\r\n    filter: Filter<TSchema>,\r\n    replacement: WithoutId<TSchema>,\r\n    options: FindOneAndReplaceOptions & { includeResultMetadata: true }\r\n  ): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndReplace(\r\n    filter: Filter<TSchema>,\r\n    replacement: WithoutId<TSchema>,\r\n    options: FindOneAndReplaceOptions & { includeResultMetadata: false }\r\n  ): Promise<WithId<TSchema> | null>;\r\n  async findOneAndReplace(\r\n    filter: Filter<TSchema>,\r\n    replacement: WithoutId<TSchema>,\r\n    options: FindOneAndReplaceOptions\r\n  ): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndReplace(\r\n    filter: Filter<TSchema>,\r\n    replacement: WithoutId<TSchema>\r\n  ): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndReplace(\r\n    filter: Filter<TSchema>,\r\n    replacement: WithoutId<TSchema>,\r\n    options?: FindOneAndReplaceOptions\r\n  ): Promise<WithId<TSchema> | ModifyResult<TSchema> | null> {\r\n    return executeOperation(\r\n      this.client,\r\n      new FindOneAndReplaceOperation(\r\n        this as TODO_NODE_3286,\r\n        filter,\r\n        replacement,\r\n        resolveOptions(this, options)\r\n      ) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\r\n   *\r\n   * @param filter - The filter used to select the document to update\r\n   * @param update - Update operations to be performed on the document\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async findOneAndUpdate(\r\n    filter: Filter<TSchema>,\r\n    update: UpdateFilter<TSchema>,\r\n    options: FindOneAndUpdateOptions & { includeResultMetadata: true }\r\n  ): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndUpdate(\r\n    filter: Filter<TSchema>,\r\n    update: UpdateFilter<TSchema>,\r\n    options: FindOneAndUpdateOptions & { includeResultMetadata: false }\r\n  ): Promise<WithId<TSchema> | null>;\r\n  async findOneAndUpdate(\r\n    filter: Filter<TSchema>,\r\n    update: UpdateFilter<TSchema>,\r\n    options: FindOneAndUpdateOptions\r\n  ): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndUpdate(\r\n    filter: Filter<TSchema>,\r\n    update: UpdateFilter<TSchema>\r\n  ): Promise<ModifyResult<TSchema>>;\r\n  async findOneAndUpdate(\r\n    filter: Filter<TSchema>,\r\n    update: UpdateFilter<TSchema>,\r\n    options?: FindOneAndUpdateOptions\r\n  ): Promise<WithId<TSchema> | ModifyResult<TSchema> | null> {\r\n    return executeOperation(\r\n      this.client,\r\n      new FindOneAndUpdateOperation(\r\n        this as TODO_NODE_3286,\r\n        filter,\r\n        update,\r\n        resolveOptions(this, options)\r\n      ) as TODO_NODE_3286\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\r\n   *\r\n   * @param pipeline - An array of aggregation pipelines to execute\r\n   * @param options - Optional settings for the command\r\n   */\r\n  aggregate<T extends Document = Document>(\r\n    pipeline: Document[] = [],\r\n    options?: AggregateOptions\r\n  ): AggregationCursor<T> {\r\n    if (!Array.isArray(pipeline)) {\r\n      throw new MongoInvalidArgumentError(\r\n        'Argument \"pipeline\" must be an array of aggregation stages'\r\n      );\r\n    }\r\n\r\n    return new AggregationCursor(\r\n      this.client,\r\n      this.s.namespace,\r\n      pipeline,\r\n      resolveOptions(this, options)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\r\n   *\r\n   * @remarks\r\n   * watch() accepts two generic arguments for distinct use cases:\r\n   * - The first is to override the schema that may be defined for this specific collection\r\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\r\n   * @example\r\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\r\n   * ```ts\r\n   * collection.watch<{ _id: number }>()\r\n   *   .on('change', change => console.log(change._id.toFixed(4)));\r\n   * ```\r\n   *\r\n   * @example\r\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\r\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\r\n   * No need start from scratch on the ChangeStreamInsertDocument type!\r\n   * By using an intersection we can save time and ensure defaults remain the same type!\r\n   * ```ts\r\n   * collection\r\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\r\n   *     { $addFields: { comment: 'big changes' } },\r\n   *     { $match: { operationType: 'insert' } }\r\n   *   ])\r\n   *   .on('change', change => {\r\n   *     change.comment.startsWith('big');\r\n   *     change.operationType === 'insert';\r\n   *     // No need to narrow in code because the generics did that for us!\r\n   *     expectType<Schema>(change.fullDocument);\r\n   *   });\r\n   * ```\r\n   *\r\n   * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\r\n   * @param options - Optional settings for the command\r\n   * @typeParam TLocal - Type of the data being detected by the change stream\r\n   * @typeParam TChange - Type of the whole change stream document emitted\r\n   */\r\n  watch<TLocal extends Document = TSchema, TChange extends Document = ChangeStreamDocument<TLocal>>(\r\n    pipeline: Document[] = [],\r\n    options: ChangeStreamOptions = {}\r\n  ): ChangeStream<TLocal, TChange> {\r\n    // Allow optionally not specifying a pipeline\r\n    if (!Array.isArray(pipeline)) {\r\n      options = pipeline;\r\n      pipeline = [];\r\n    }\r\n\r\n    return new ChangeStream<TLocal, TChange>(this, pipeline, resolveOptions(this, options));\r\n  }\r\n\r\n  /**\r\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\r\n   *\r\n   * @throws MongoNotConnectedError\r\n   * @remarks\r\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\r\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\r\n   */\r\n  initializeUnorderedBulkOp(options?: BulkWriteOptions): UnorderedBulkOperation {\r\n    return new UnorderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\r\n  }\r\n\r\n  /**\r\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\r\n   *\r\n   * @throws MongoNotConnectedError\r\n   * @remarks\r\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.\r\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\r\n   */\r\n  initializeOrderedBulkOp(options?: BulkWriteOptions): OrderedBulkOperation {\r\n    return new OrderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\r\n  }\r\n\r\n  /**\r\n   * An estimated count of matching documents in the db to a filter.\r\n   *\r\n   * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\r\n   * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\r\n   * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\r\n   *\r\n   * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\r\n   *\r\n   * @param filter - The filter for the count.\r\n   * @param options - Optional settings for the command\r\n   */\r\n  async count(filter: Filter<TSchema> = {}, options: CountOptions = {}): Promise<number> {\r\n    return executeOperation(\r\n      this.client,\r\n      new CountOperation(this.fullNamespace, filter, resolveOptions(this, options))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns all search indexes for the current collection.\r\n   *\r\n   * @param options - The options for the list indexes operation.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   */\r\n  listSearchIndexes(options?: ListSearchIndexesOptions): ListSearchIndexesCursor;\r\n  /**\r\n   * Returns all search indexes for the current collection.\r\n   *\r\n   * @param name - The name of the index to search for.  Only indexes with matching index names will be returned.\r\n   * @param options - The options for the list indexes operation.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   */\r\n  listSearchIndexes(name: string, options?: ListSearchIndexesOptions): ListSearchIndexesCursor;\r\n  listSearchIndexes(\r\n    indexNameOrOptions?: string | ListSearchIndexesOptions,\r\n    options?: ListSearchIndexesOptions\r\n  ): ListSearchIndexesCursor {\r\n    options =\r\n      typeof indexNameOrOptions === 'object' ? indexNameOrOptions : options == null ? {} : options;\r\n    const indexName =\r\n      indexNameOrOptions == null\r\n        ? null\r\n        : typeof indexNameOrOptions === 'object'\r\n        ? null\r\n        : indexNameOrOptions;\r\n\r\n    return new ListSearchIndexesCursor(this as TODO_NODE_3286, indexName, options);\r\n  }\r\n\r\n  /**\r\n   * Creates a single search index for the collection.\r\n   *\r\n   * @param description - The index description for the new search index.\r\n   * @returns A promise that resolves to the name of the new search index.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   */\r\n  async createSearchIndex(description: SearchIndexDescription): Promise<string> {\r\n    const [index] = await this.createSearchIndexes([description]);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Creates multiple search indexes for the current collection.\r\n   *\r\n   * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.\r\n   * @returns A promise that resolves to an array of the newly created search index names.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   * @returns\r\n   */\r\n  async createSearchIndexes(descriptions: SearchIndexDescription[]): Promise<string[]> {\r\n    return executeOperation(\r\n      this.client,\r\n      new CreateSearchIndexesOperation(this as TODO_NODE_3286, descriptions)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Deletes a search index by index name.\r\n   *\r\n   * @param name - The name of the search index to be deleted.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   */\r\n  async dropSearchIndex(name: string): Promise<void> {\r\n    return executeOperation(\r\n      this.client,\r\n      new DropSearchIndexOperation(this as TODO_NODE_3286, name)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Updates a search index by replacing the existing index definition with the provided definition.\r\n   *\r\n   * @param name - The name of the search index to update.\r\n   * @param definition - The new search index definition.\r\n   *\r\n   * @remarks Only available when used against a 7.0+ Atlas cluster.\r\n   */\r\n  async updateSearchIndex(name: string, definition: Document): Promise<void> {\r\n    return executeOperation(\r\n      this.client,\r\n      new UpdateSearchIndexOperation(this as TODO_NODE_3286, name, definition)\r\n    );\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}