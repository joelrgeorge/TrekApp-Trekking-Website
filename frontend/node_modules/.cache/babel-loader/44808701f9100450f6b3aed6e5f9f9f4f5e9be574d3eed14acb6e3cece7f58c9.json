{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KillCursorsOperation = void 0;\nconst error_1 = require(\"../error\");\nconst operation_1 = require(\"./operation\");\nclass KillCursorsOperation extends operation_1.AbstractCallbackOperation {\n  constructor(cursorId, ns, server, options) {\n    super(options);\n    this.ns = ns;\n    this.cursorId = cursorId;\n    this.server = server;\n  }\n  executeCallback(server, session, callback) {\n    if (server !== this.server) {\n      return callback(new error_1.MongoRuntimeError('Killcursor must run on the same server operation began on'));\n    }\n    const killCursors = this.ns.collection;\n    if (killCursors == null) {\n      // Cursors should have adopted the namespace returned by MongoDB\n      // which should always defined a collection name (even a pseudo one, ex. db.aggregate())\n      return callback(new error_1.MongoRuntimeError('A collection name must be determined before killCursors'));\n    }\n    const killCursorsCommand = {\n      killCursors,\n      cursors: [this.cursorId]\n    };\n    server.command(this.ns, killCursorsCommand, {\n      session\n    }, () => callback());\n  }\n}\nexports.KillCursorsOperation = KillCursorsOperation;\n(0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);","map":{"version":3,"mappings":";;;;;;AACA;AAIA;AAiBA,MAAaA,oBAAqB,SAAQC,qCAAyB;EAGjEC,YAAYC,QAAc,EAAEC,EAAoB,EAAEC,MAAc,EAAEC,OAAyB;IACzF,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACF,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACE,MAAM,GAAGA,MAAM;EACtB;EAEAE,eAAe,CACbF,MAAc,EACdG,OAAkC,EAClCC,QAAwB;IAExB,IAAIJ,MAAM,KAAK,IAAI,CAACA,MAAM,EAAE;MAC1B,OAAOI,QAAQ,CACb,IAAIC,yBAAiB,CAAC,2DAA2D,CAAC,CACnF;;IAGH,MAAMC,WAAW,GAAG,IAAI,CAACP,EAAE,CAACQ,UAAU;IACtC,IAAID,WAAW,IAAI,IAAI,EAAE;MACvB;MACA;MACA,OAAOF,QAAQ,CACb,IAAIC,yBAAiB,CAAC,yDAAyD,CAAC,CACjF;;IAGH,MAAMG,kBAAkB,GAAuB;MAC7CF,WAAW;MACXG,OAAO,EAAE,CAAC,IAAI,CAACX,QAAQ;KACxB;IAEDE,MAAM,CAACU,OAAO,CAAC,IAAI,CAACX,EAAE,EAAES,kBAAkB,EAAE;MAAEL;IAAO,CAAE,EAAE,MAAMC,QAAQ,EAAE,CAAC;EAC5E;;AApCFO;AAuCA,6BAAa,EAAChB,oBAAoB,EAAE,CAACC,kBAAM,CAACgB,uBAAuB,CAAC,CAAC","names":["KillCursorsOperation","operation_1","constructor","cursorId","ns","server","options","executeCallback","session","callback","error_1","killCursors","collection","killCursorsCommand","cursors","command","exports","MUST_SELECT_SAME_SERVER"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\operations\\kill_cursors.ts"],"sourcesContent":["import type { Long } from '../bson';\r\nimport { MongoRuntimeError } from '../error';\r\nimport type { Server } from '../sdam/server';\r\nimport type { ClientSession } from '../sessions';\r\nimport type { Callback, MongoDBNamespace } from '../utils';\r\nimport {\r\n  AbstractCallbackOperation,\r\n  Aspect,\r\n  defineAspects,\r\n  type OperationOptions\r\n} from './operation';\r\n\r\n/**\r\n * https://www.mongodb.com/docs/manual/reference/command/killCursors/\r\n * @internal\r\n */\r\ninterface KillCursorsCommand {\r\n  killCursors: string;\r\n  cursors: Long[];\r\n  comment?: unknown;\r\n}\r\n\r\nexport class KillCursorsOperation extends AbstractCallbackOperation {\r\n  cursorId: Long;\r\n\r\n  constructor(cursorId: Long, ns: MongoDBNamespace, server: Server, options: OperationOptions) {\r\n    super(options);\r\n    this.ns = ns;\r\n    this.cursorId = cursorId;\r\n    this.server = server;\r\n  }\r\n\r\n  executeCallback(\r\n    server: Server,\r\n    session: ClientSession | undefined,\r\n    callback: Callback<void>\r\n  ): void {\r\n    if (server !== this.server) {\r\n      return callback(\r\n        new MongoRuntimeError('Killcursor must run on the same server operation began on')\r\n      );\r\n    }\r\n\r\n    const killCursors = this.ns.collection;\r\n    if (killCursors == null) {\r\n      // Cursors should have adopted the namespace returned by MongoDB\r\n      // which should always defined a collection name (even a pseudo one, ex. db.aggregate())\r\n      return callback(\r\n        new MongoRuntimeError('A collection name must be determined before killCursors')\r\n      );\r\n    }\r\n\r\n    const killCursorsCommand: KillCursorsCommand = {\r\n      killCursors,\r\n      cursors: [this.cursorId]\r\n    };\r\n\r\n    server.command(this.ns, killCursorsCommand, { session }, () => callback());\r\n  }\r\n}\r\n\r\ndefineAspects(KillCursorsOperation, [Aspect.MUST_SELECT_SAME_SERVER]);\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}