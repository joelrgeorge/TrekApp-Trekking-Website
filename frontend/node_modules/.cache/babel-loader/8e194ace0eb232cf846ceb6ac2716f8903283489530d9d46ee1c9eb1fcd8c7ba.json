{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kClient = Symbol('client');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @internal */\nconst kInit = Symbol('kInit');\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace, options = {}) {\n    super();\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kId] = null;\n    this[kDocuments] = new utils_1.List();\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    };\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n  }\n  get id() {\n    return this[kId] ?? undefined;\n  }\n  /** @internal */\n  get client() {\n    return this[kClient];\n  }\n  /** @internal */\n  get server() {\n    return this[kServer];\n  }\n  get namespace() {\n    return this[kNamespace];\n  }\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this[kSession];\n  }\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n  get cursorOptions() {\n    return this[kOptions];\n  }\n  get closed() {\n    return this[kClosed];\n  }\n  get killed() {\n    return this[kKilled];\n  }\n  get loadBalanced() {\n    return !!this[kClient].topology?.loadBalanced;\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    const bufferedDocs = [];\n    const documentsToRead = Math.min(number ?? this[kDocuments].length, this[kDocuments].length);\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this[kDocuments].shift();\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n    return bufferedDocs;\n  }\n  async *[Symbol.asyncIterator]() {\n    if (this.closed) {\n      return;\n    }\n    try {\n      while (true) {\n        const document = await this.next();\n        // Intentional strict null check, because users can map cursors to falsey values.\n        // We allow mapping to all values except for null.\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          if (!this.closed) {\n            const message = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n            await cleanupCursorAsync(this, {\n              needsToEmitClosed: true\n            }).catch(() => null);\n            throw new error_1.MongoAPIError(message);\n          }\n          break;\n        }\n        yield document;\n        if (this[kId] === bson_1.Long.ZERO) {\n          // Cursor exhausted\n          break;\n        }\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.closed) {\n        await this.close().catch(() => null);\n      }\n    }\n  }\n  stream(options) {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n      return readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n      }));\n    }\n    return new ReadableCursorStream(this);\n  }\n  async hasNext() {\n    if (this[kId] === bson_1.Long.ZERO) {\n      return false;\n    }\n    if (this[kDocuments].length !== 0) {\n      return true;\n    }\n    const doc = await next(this, {\n      blocking: true,\n      transform: false\n    });\n    if (doc) {\n      this[kDocuments].unshift(doc);\n      return true;\n    }\n    return false;\n  }\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next() {\n    if (this[kId] === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    return next(this, {\n      blocking: true,\n      transform: true\n    });\n  }\n  /**\r\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\r\n   */\n  async tryNext() {\n    if (this[kId] === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    return next(this, {\n      blocking: false,\n      transform: true\n    });\n  }\n  /**\r\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\r\n   *\r\n   * If the iterator returns `false`, iteration will stop.\r\n   *\r\n   * @param iterator - The iteration callback.\r\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\r\n   */\n  async forEach(iterator) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n  async close() {\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    await cleanupCursorAsync(this, {\n      needsToEmitClosed\n    });\n  }\n  /**\r\n   * Returns an array of documents. The caller is responsible for making sure that there\r\n   * is enough memory to store the results. Note that the array only contains partial\r\n   * results when this cursor had been previously accessed. In that case,\r\n   * cursor.rewind() can be used to reset the cursor.\r\n   */\n  async toArray() {\n    const array = [];\n    for await (const document of this) {\n      array.push(document);\n    }\n    return array;\n  }\n  /**\r\n   * Add a cursor flag to the cursor\r\n   *\r\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\r\n   * @param value - The flag boolean value.\r\n   */\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\r\n   * Map all documents using the provided function\r\n   * If there is a transform set on the cursor, that will be called first and the result passed to\r\n   * this function's transform.\r\n   *\r\n   * @remarks\r\n   *\r\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\r\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\r\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\r\n   *\r\n   * ```typescript\r\n   * const cursor = collection.find({});\r\n   * cursor.map(() => null);\r\n   *\r\n   * const documents = await cursor.toArray();\r\n   * // documents is always [], regardless of how many documents are in the collection.\r\n   * ```\r\n   *\r\n   * Other falsey values are allowed:\r\n   *\r\n   * ```typescript\r\n   * const cursor = collection.find({});\r\n   * cursor.map(() => '');\r\n   *\r\n   * const documents = await cursor.toArray();\r\n   * // documents is now an array of empty strings\r\n   * ```\r\n   *\r\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\r\n   * it **does not** return a new instance of a cursor. This means when calling map,\r\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\r\n   * Take note of the following example:\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const cursor: FindCursor<Document> = coll.find();\r\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\r\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\r\n   * ```\r\n   * @param transform - The mapping transformation method.\r\n   */\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n    return this;\n  }\n  /**\r\n   * Set the ReadPreference for the cursor.\r\n   *\r\n   * @param readPreference - The new read preference for the cursor.\r\n   */\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n    return this;\n  }\n  /**\r\n   * Set the ReadPreference for the cursor.\r\n   *\r\n   * @param readPreference - The new read preference for the cursor.\r\n   */\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\r\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\r\n   *\r\n   * @param value - Number of milliseconds to wait before aborting the query.\r\n   */\n  maxTimeMS(value) {\n    assertUninitialized(this);\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\r\n   * Set the batch size for the cursor.\r\n   *\r\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\r\n   */\n  batchSize(value) {\n    assertUninitialized(this);\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\r\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\r\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\r\n   * if the resultant data has already been retrieved by this cursor.\r\n   */\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n    this[kId] = null;\n    this[kDocuments].clear();\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().catch(() => null);\n        }\n        this[kSession] = this.client.startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n  }\n  /** @internal */\n  _getMore(batchSize, callback) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], {\n      ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    });\n    (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);\n  }\n  /**\r\n   * @internal\r\n   *\r\n   * This function is exposed for the unified test runner's createChangeStream\r\n   * operation.  We cannot refactor to use the abstract _initialize method without\r\n   * a significant refactor.\r\n   */\n  [kInit](callback) {\n    this._initialize(this[kSession], (error, state) => {\n      if (state) {\n        const response = state.response;\n        this[kServer] = state.server;\n        if (response.cursor) {\n          // TODO(NODE-2674): Preserve int64 sent from MongoDB\n          this[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === 'bigint' ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;\n          if (response.cursor.ns) {\n            this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n          }\n          this[kDocuments].pushMany(response.cursor.firstBatch);\n        }\n        // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n        if (this[kId] == null) {\n          this[kId] = bson_1.Long.ZERO;\n          // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n          this[kDocuments].push(state.response);\n        }\n      }\n      // the cursor is now initialized, even if an error occurred or it is dead\n      this[kInitialized] = true;\n      if (error) {\n        return cleanupCursor(this, {\n          error\n        }, () => callback(error, undefined));\n      }\n      if (cursorIsDead(this)) {\n        return cleanupCursor(this, undefined, () => callback());\n      }\n      callback();\n    });\n  }\n}\n/** @event */\nAbstractCursor.CLOSE = 'close';\nexports.AbstractCursor = AbstractCursor;\n/**\r\n * @param cursor - the cursor on which to call `next`\r\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\r\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\r\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\r\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\r\n *     not indicate the end of the cursor.\r\n * @param transform - if true, the cursor's transform function is applied to the result document (if the transform exists)\r\n * @returns the next document in the cursor, or `null`.  When `blocking` is `true`, a `null` document means\r\n * the cursor has been exhausted.  Otherwise, it means that there is no document available in the cursor's buffer.\r\n */\nasync function next(cursor, {\n  blocking,\n  transform\n}) {\n  const cursorId = cursor[kId];\n  if (cursor.closed) {\n    return null;\n  }\n  if (cursor[kDocuments].length !== 0) {\n    const doc = cursor[kDocuments].shift();\n    if (doc != null && transform && cursor[kTransform]) {\n      try {\n        return cursor[kTransform](doc);\n      } catch (error) {\n        await cleanupCursorAsync(cursor, {\n          error,\n          needsToEmitClosed: true\n        }).catch(() => {\n          // `cleanupCursorAsync` should never throw, but if it does we want to throw the original\n          // error instead.\n        });\n        throw error;\n      }\n    }\n    return doc;\n  }\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    const init = (0, util_1.promisify)(cb => cursor[kInit](cb));\n    await init();\n    return next(cursor, {\n      blocking,\n      transform\n    });\n  }\n  if (cursorIsDead(cursor)) {\n    // if the cursor is dead, we clean it up\n    // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n    // and we should surface the error\n    await cleanupCursorAsync(cursor, {});\n    return null;\n  }\n  // otherwise need to call getMore\n  const batchSize = cursor[kOptions].batchSize || 1000;\n  const getMore = (0, util_1.promisify)((batchSize, cb) => cursor._getMore(batchSize, cb));\n  let response;\n  try {\n    response = await getMore(batchSize);\n  } catch (error) {\n    if (error) {\n      await cleanupCursorAsync(cursor, {\n        error\n      }).catch(() => {\n        // `cleanupCursorAsync` should never throw, but if it does we want to throw the original\n        // error instead.\n      });\n      throw error;\n    }\n  }\n  if (response) {\n    const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === 'bigint' ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;\n    cursor[kDocuments].pushMany(response.cursor.nextBatch);\n    cursor[kId] = cursorId;\n  }\n  if (cursorIsDead(cursor)) {\n    // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n    // we intentionally clean up the cursor to release its session back into the pool before the cursor\n    // is iterated.  This prevents a cursor that is exhausted on the server from holding\n    // onto a session indefinitely until the AbstractCursor is iterated.\n    //\n    // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n    // and we should surface the error\n    await cleanupCursorAsync(cursor, {});\n  }\n  if (cursor[kDocuments].length === 0 && blocking === false) {\n    return null;\n  }\n  return next(cursor, {\n    blocking,\n    transform\n  });\n}\nfunction cursorIsDead(cursor) {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\nconst cleanupCursorAsync = (0, util_1.promisify)(cleanupCursor);\nfunction cleanupCursor(cursor, options, callback) {\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options?.error;\n  // Cursors only emit closed events once the client-side cursor has been exhausted fully or there\n  // was an error.  Notably, when the server returns a cursor id of 0 and a non-empty batch, we\n  // cleanup the cursor but don't emit a `close` event.\n  const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n    if (session) {\n      if (session.owner === cursor) {\n        session.endSession({\n          error\n        }).finally(() => {\n          callback();\n        });\n        return;\n      }\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n    return callback();\n  }\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        session.endSession({\n          error\n        }).finally(() => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n        return;\n      }\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n  cursor[kKilled] = true;\n  if (session.hasEnded) {\n    return completeCleanup();\n  }\n  (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {\n    session\n  })).catch(() => null).finally(completeCleanup);\n}\n/** @internal */\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.assertUninitialized = assertUninitialized;\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n  _destroy(error, callback) {\n    this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n  }\n  _readNext() {\n    next(this._cursor, {\n      blocking: true,\n      transform: true\n    }).then(result => {\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().catch(() => null);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n        this._readInProgress = false;\n      }\n    }, err => {\n      // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n      //       desired behavior is that a stream ends cleanly when a user explicitly closes\n      //       a client during iteration. Alternatively, we could do the \"right\" thing and\n      //       propagate the error message by removing this special case.\n      if (err.message.match(/server is closed/)) {\n        this._cursor.close().catch(() => null);\n        return this.push(null);\n      }\n      // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n      //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n      //       active getMore in-flight. This used to check if the cursor was killed but once\n      //       that changed to happen in cleanup legitimate errors would not destroy the\n      //       stream. There are change streams test specifically test these cases.\n      if (err.message.match(/operation was interrupted/)) {\n        return this.push(null);\n      }\n      // NOTE: The two above checks on the message of the error will cause a null to be pushed\n      //       to the stream, thus closing the stream before the destroy call happens. This means\n      //       that either of those error messages on a change stream will not get a proper\n      //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n      //       relies on that error event to be emitted to create its new cursor and thus was not\n      //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n      //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n      //       See NODE-4475.\n      return this.destroy(err);\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["kId","Symbol","kDocuments","kServer","kNamespace","kClient","kSession","kOptions","kTransform","kInitialized","kClosed","kKilled","kInit","exports","AbstractCursor","mongo_types_1","constructor","client","namespace","options","s","isMongoClient","error_1","utils_1","readPreference","read_preference_1","primary","readConcern","read_concern_1","fromOptions","batchSize","comment","undefined","maxTimeMS","maxAwaitTimeMS","session","sessions_1","startSession","owner","explicit","id","server","clientSession","cursorOptions","closed","killed","loadBalanced","topology","bufferedCount","length","readBufferedDocuments","number","bufferedDocs","documentsToRead","Math","min","count","document","shift","push","asyncIterator","next","message","cleanupCursorAsync","needsToEmitClosed","catch","bson_1","ZERO","close","stream","transform","readable","ReadableCursorStream","pipe","stream_1","objectMode","highWaterMark","chunk","_","callback","transformed","err","hasNext","doc","blocking","unshift","tryNext","forEach","iterator","result","toArray","array","addCursorFlag","flag","value","assertUninitialized","includes","map","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","rewind","clear","hasEnded","endSession","_getMore","getMoreOperation","get_more_1","_initialize","error","state","response","cursor","fromNumber","fromBigInt","ns","pushMany","firstBatch","cleanupCursor","cursorIsDead","cursorId","init","cb","getMore","nextBatch","isZero","cursorNs","completeCleanup","emit","CLOSE","finally","inTransaction","kill_cursors_1","autoDestroy","_cursor","_read","size","_readInProgress","_readNext","_destroy","then","closeError","destroyed","match","destroy"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\cursor\\abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\r\nimport { promisify } from 'util';\r\n\r\nimport { type BSONSerializeOptions, type Document, Long, pluckBSONSerializeOptions } from '../bson';\r\nimport {\r\n  type AnyError,\r\n  MongoAPIError,\r\n  MongoCursorExhaustedError,\r\n  MongoCursorInUseError,\r\n  MongoInvalidArgumentError,\r\n  MongoNetworkError,\r\n  MongoRuntimeError,\r\n  MongoTailableCursorError\r\n} from '../error';\r\nimport type { MongoClient } from '../mongo_client';\r\nimport { type TODO_NODE_3286, TypedEventEmitter } from '../mongo_types';\r\nimport { executeOperation, type ExecutionResult } from '../operations/execute_operation';\r\nimport { GetMoreOperation } from '../operations/get_more';\r\nimport { KillCursorsOperation } from '../operations/kill_cursors';\r\nimport { ReadConcern, type ReadConcernLike } from '../read_concern';\r\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\r\nimport type { Server } from '../sdam/server';\r\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\r\nimport { type Callback, List, type MongoDBNamespace, ns } from '../utils';\r\n\r\n/** @internal */\r\nconst kId = Symbol('id');\r\n/** @internal */\r\nconst kDocuments = Symbol('documents');\r\n/** @internal */\r\nconst kServer = Symbol('server');\r\n/** @internal */\r\nconst kNamespace = Symbol('namespace');\r\n/** @internal */\r\nconst kClient = Symbol('client');\r\n/** @internal */\r\nconst kSession = Symbol('session');\r\n/** @internal */\r\nconst kOptions = Symbol('options');\r\n/** @internal */\r\nconst kTransform = Symbol('transform');\r\n/** @internal */\r\nconst kInitialized = Symbol('initialized');\r\n/** @internal */\r\nconst kClosed = Symbol('closed');\r\n/** @internal */\r\nconst kKilled = Symbol('killed');\r\n/** @internal */\r\nconst kInit = Symbol('kInit');\r\n\r\n/** @public */\r\nexport const CURSOR_FLAGS = [\r\n  'tailable',\r\n  'oplogReplay',\r\n  'noCursorTimeout',\r\n  'awaitData',\r\n  'exhaust',\r\n  'partial'\r\n] as const;\r\n\r\n/** @public */\r\nexport interface CursorStreamOptions {\r\n  /** A transformation method applied to each document emitted by the stream */\r\n  transform?(this: void, doc: Document): Document;\r\n}\r\n\r\n/** @public */\r\nexport type CursorFlag = (typeof CURSOR_FLAGS)[number];\r\n\r\n/** @public */\r\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\r\n  session?: ClientSession;\r\n  readPreference?: ReadPreferenceLike;\r\n  readConcern?: ReadConcernLike;\r\n  /**\r\n   * Specifies the number of documents to return in each response from MongoDB\r\n   */\r\n  batchSize?: number;\r\n  /**\r\n   * When applicable `maxTimeMS` controls the amount of time the initial command\r\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\r\n   */\r\n  maxTimeMS?: number;\r\n  /**\r\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\r\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\r\n   */\r\n  maxAwaitTimeMS?: number;\r\n  /**\r\n   * Comment to apply to the operation.\r\n   *\r\n   * In server versions pre-4.4, 'comment' must be string.  A server\r\n   * error will be thrown if any other type is provided.\r\n   *\r\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\r\n   */\r\n  comment?: unknown;\r\n  /**\r\n   * By default, MongoDB will automatically close a cursor when the\r\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\r\n   * you may use a Tailable Cursor that remains open after the client exhausts\r\n   * the results in the initial cursor.\r\n   */\r\n  tailable?: boolean;\r\n  /**\r\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\r\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\r\n   * When new data is inserted into the capped collection, the blocked thread is signaled\r\n   * to wake up and return the next batch to the client.\r\n   */\r\n  awaitData?: boolean;\r\n  noCursorTimeout?: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\r\n  // resolved\r\n  readPreference: ReadPreference;\r\n  readConcern?: ReadConcern;\r\n\r\n  // cursor flags, some are deprecated\r\n  oplogReplay?: boolean;\r\n  exhaust?: boolean;\r\n  partial?: boolean;\r\n};\r\n\r\n/** @public */\r\nexport type AbstractCursorEvents = {\r\n  [AbstractCursor.CLOSE](): void;\r\n};\r\n\r\n/** @public */\r\nexport abstract class AbstractCursor<\r\n  TSchema = any,\r\n  CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\r\n> extends TypedEventEmitter<CursorEvents> {\r\n  /** @internal */\r\n  [kId]: Long | null;\r\n  /** @internal */\r\n  [kSession]: ClientSession;\r\n  /** @internal */\r\n  [kServer]?: Server;\r\n  /** @internal */\r\n  [kNamespace]: MongoDBNamespace;\r\n  /** @internal */\r\n  [kDocuments]: List<TSchema>;\r\n  /** @internal */\r\n  [kClient]: MongoClient;\r\n  /** @internal */\r\n  [kTransform]?: (doc: TSchema) => any;\r\n  /** @internal */\r\n  [kInitialized]: boolean;\r\n  /** @internal */\r\n  [kClosed]: boolean;\r\n  /** @internal */\r\n  [kKilled]: boolean;\r\n  /** @internal */\r\n  [kOptions]: InternalAbstractCursorOptions;\r\n\r\n  /** @event */\r\n  static readonly CLOSE = 'close' as const;\r\n\r\n  /** @internal */\r\n  constructor(\r\n    client: MongoClient,\r\n    namespace: MongoDBNamespace,\r\n    options: AbstractCursorOptions = {}\r\n  ) {\r\n    super();\r\n\r\n    if (!client.s.isMongoClient) {\r\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\r\n    }\r\n    this[kClient] = client;\r\n    this[kNamespace] = namespace;\r\n    this[kId] = null;\r\n    this[kDocuments] = new List();\r\n    this[kInitialized] = false;\r\n    this[kClosed] = false;\r\n    this[kKilled] = false;\r\n    this[kOptions] = {\r\n      readPreference:\r\n        options.readPreference && options.readPreference instanceof ReadPreference\r\n          ? options.readPreference\r\n          : ReadPreference.primary,\r\n      ...pluckBSONSerializeOptions(options)\r\n    };\r\n\r\n    const readConcern = ReadConcern.fromOptions(options);\r\n    if (readConcern) {\r\n      this[kOptions].readConcern = readConcern;\r\n    }\r\n\r\n    if (typeof options.batchSize === 'number') {\r\n      this[kOptions].batchSize = options.batchSize;\r\n    }\r\n\r\n    // we check for undefined specifically here to allow falsy values\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    if (options.comment !== undefined) {\r\n      this[kOptions].comment = options.comment;\r\n    }\r\n\r\n    if (typeof options.maxTimeMS === 'number') {\r\n      this[kOptions].maxTimeMS = options.maxTimeMS;\r\n    }\r\n\r\n    if (typeof options.maxAwaitTimeMS === 'number') {\r\n      this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\r\n    }\r\n\r\n    if (options.session instanceof ClientSession) {\r\n      this[kSession] = options.session;\r\n    } else {\r\n      this[kSession] = this[kClient].startSession({ owner: this, explicit: false });\r\n    }\r\n  }\r\n\r\n  get id(): Long | undefined {\r\n    return this[kId] ?? undefined;\r\n  }\r\n\r\n  /** @internal */\r\n  get client(): MongoClient {\r\n    return this[kClient];\r\n  }\r\n\r\n  /** @internal */\r\n  get server(): Server | undefined {\r\n    return this[kServer];\r\n  }\r\n\r\n  get namespace(): MongoDBNamespace {\r\n    return this[kNamespace];\r\n  }\r\n\r\n  get readPreference(): ReadPreference {\r\n    return this[kOptions].readPreference;\r\n  }\r\n\r\n  get readConcern(): ReadConcern | undefined {\r\n    return this[kOptions].readConcern;\r\n  }\r\n\r\n  /** @internal */\r\n  get session(): ClientSession {\r\n    return this[kSession];\r\n  }\r\n\r\n  set session(clientSession: ClientSession) {\r\n    this[kSession] = clientSession;\r\n  }\r\n\r\n  /** @internal */\r\n  get cursorOptions(): InternalAbstractCursorOptions {\r\n    return this[kOptions];\r\n  }\r\n\r\n  get closed(): boolean {\r\n    return this[kClosed];\r\n  }\r\n\r\n  get killed(): boolean {\r\n    return this[kKilled];\r\n  }\r\n\r\n  get loadBalanced(): boolean {\r\n    return !!this[kClient].topology?.loadBalanced;\r\n  }\r\n\r\n  /** Returns current buffered documents length */\r\n  bufferedCount(): number {\r\n    return this[kDocuments].length;\r\n  }\r\n\r\n  /** Returns current buffered documents */\r\n  readBufferedDocuments(number?: number): TSchema[] {\r\n    const bufferedDocs: TSchema[] = [];\r\n    const documentsToRead = Math.min(number ?? this[kDocuments].length, this[kDocuments].length);\r\n\r\n    for (let count = 0; count < documentsToRead; count++) {\r\n      const document = this[kDocuments].shift();\r\n      if (document != null) {\r\n        bufferedDocs.push(document);\r\n      }\r\n    }\r\n\r\n    return bufferedDocs;\r\n  }\r\n\r\n  async *[Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void> {\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      while (true) {\r\n        const document = await this.next();\r\n\r\n        // Intentional strict null check, because users can map cursors to falsey values.\r\n        // We allow mapping to all values except for null.\r\n        // eslint-disable-next-line no-restricted-syntax\r\n        if (document === null) {\r\n          if (!this.closed) {\r\n            const message =\r\n              'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\r\n\r\n            await cleanupCursorAsync(this, { needsToEmitClosed: true }).catch(() => null);\r\n\r\n            throw new MongoAPIError(message);\r\n          }\r\n          break;\r\n        }\r\n\r\n        yield document;\r\n\r\n        if (this[kId] === Long.ZERO) {\r\n          // Cursor exhausted\r\n          break;\r\n        }\r\n      }\r\n    } finally {\r\n      // Only close the cursor if it has not already been closed. This finally clause handles\r\n      // the case when a user would break out of a for await of loop early.\r\n      if (!this.closed) {\r\n        await this.close().catch(() => null);\r\n      }\r\n    }\r\n  }\r\n\r\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema> {\r\n    if (options?.transform) {\r\n      const transform = options.transform;\r\n      const readable = new ReadableCursorStream(this);\r\n\r\n      return readable.pipe(\r\n        new Transform({\r\n          objectMode: true,\r\n          highWaterMark: 1,\r\n          transform(chunk, _, callback) {\r\n            try {\r\n              const transformed = transform(chunk);\r\n              callback(undefined, transformed);\r\n            } catch (err) {\r\n              callback(err);\r\n            }\r\n          }\r\n        })\r\n      );\r\n    }\r\n\r\n    return new ReadableCursorStream(this);\r\n  }\r\n\r\n  async hasNext(): Promise<boolean> {\r\n    if (this[kId] === Long.ZERO) {\r\n      return false;\r\n    }\r\n\r\n    if (this[kDocuments].length !== 0) {\r\n      return true;\r\n    }\r\n\r\n    const doc = await next<TSchema>(this, { blocking: true, transform: false });\r\n\r\n    if (doc) {\r\n      this[kDocuments].unshift(doc);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\r\n  async next(): Promise<TSchema | null> {\r\n    if (this[kId] === Long.ZERO) {\r\n      throw new MongoCursorExhaustedError();\r\n    }\r\n\r\n    return next(this, { blocking: true, transform: true });\r\n  }\r\n\r\n  /**\r\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\r\n   */\r\n  async tryNext(): Promise<TSchema | null> {\r\n    if (this[kId] === Long.ZERO) {\r\n      throw new MongoCursorExhaustedError();\r\n    }\r\n\r\n    return next(this, { blocking: false, transform: true });\r\n  }\r\n\r\n  /**\r\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\r\n   *\r\n   * If the iterator returns `false`, iteration will stop.\r\n   *\r\n   * @param iterator - The iteration callback.\r\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\r\n   */\r\n  async forEach(iterator: (doc: TSchema) => boolean | void): Promise<void> {\r\n    if (typeof iterator !== 'function') {\r\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\r\n    }\r\n    for await (const document of this) {\r\n      const result = iterator(document);\r\n      if (result === false) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    const needsToEmitClosed = !this[kClosed];\r\n    this[kClosed] = true;\r\n    await cleanupCursorAsync(this, { needsToEmitClosed });\r\n  }\r\n\r\n  /**\r\n   * Returns an array of documents. The caller is responsible for making sure that there\r\n   * is enough memory to store the results. Note that the array only contains partial\r\n   * results when this cursor had been previously accessed. In that case,\r\n   * cursor.rewind() can be used to reset the cursor.\r\n   */\r\n  async toArray(): Promise<TSchema[]> {\r\n    const array = [];\r\n    for await (const document of this) {\r\n      array.push(document);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * Add a cursor flag to the cursor\r\n   *\r\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\r\n   * @param value - The flag boolean value.\r\n   */\r\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\r\n    assertUninitialized(this);\r\n    if (!CURSOR_FLAGS.includes(flag)) {\r\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\r\n    }\r\n\r\n    if (typeof value !== 'boolean') {\r\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\r\n    }\r\n\r\n    this[kOptions][flag] = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Map all documents using the provided function\r\n   * If there is a transform set on the cursor, that will be called first and the result passed to\r\n   * this function's transform.\r\n   *\r\n   * @remarks\r\n   *\r\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\r\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\r\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\r\n   *\r\n   * ```typescript\r\n   * const cursor = collection.find({});\r\n   * cursor.map(() => null);\r\n   *\r\n   * const documents = await cursor.toArray();\r\n   * // documents is always [], regardless of how many documents are in the collection.\r\n   * ```\r\n   *\r\n   * Other falsey values are allowed:\r\n   *\r\n   * ```typescript\r\n   * const cursor = collection.find({});\r\n   * cursor.map(() => '');\r\n   *\r\n   * const documents = await cursor.toArray();\r\n   * // documents is now an array of empty strings\r\n   * ```\r\n   *\r\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\r\n   * it **does not** return a new instance of a cursor. This means when calling map,\r\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\r\n   * Take note of the following example:\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const cursor: FindCursor<Document> = coll.find();\r\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\r\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\r\n   * ```\r\n   * @param transform - The mapping transformation method.\r\n   */\r\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\r\n    assertUninitialized(this);\r\n    const oldTransform = this[kTransform] as (doc: TSchema) => TSchema; // TODO(NODE-3283): Improve transform typing\r\n    if (oldTransform) {\r\n      this[kTransform] = doc => {\r\n        return transform(oldTransform(doc));\r\n      };\r\n    } else {\r\n      this[kTransform] = transform;\r\n    }\r\n\r\n    return this as unknown as AbstractCursor<T>;\r\n  }\r\n\r\n  /**\r\n   * Set the ReadPreference for the cursor.\r\n   *\r\n   * @param readPreference - The new read preference for the cursor.\r\n   */\r\n  withReadPreference(readPreference: ReadPreferenceLike): this {\r\n    assertUninitialized(this);\r\n    if (readPreference instanceof ReadPreference) {\r\n      this[kOptions].readPreference = readPreference;\r\n    } else if (typeof readPreference === 'string') {\r\n      this[kOptions].readPreference = ReadPreference.fromString(readPreference);\r\n    } else {\r\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the ReadPreference for the cursor.\r\n   *\r\n   * @param readPreference - The new read preference for the cursor.\r\n   */\r\n  withReadConcern(readConcern: ReadConcernLike): this {\r\n    assertUninitialized(this);\r\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\r\n    if (resolvedReadConcern) {\r\n      this[kOptions].readConcern = resolvedReadConcern;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\r\n   *\r\n   * @param value - Number of milliseconds to wait before aborting the query.\r\n   */\r\n  maxTimeMS(value: number): this {\r\n    assertUninitialized(this);\r\n    if (typeof value !== 'number') {\r\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\r\n    }\r\n\r\n    this[kOptions].maxTimeMS = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the batch size for the cursor.\r\n   *\r\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\r\n   */\r\n  batchSize(value: number): this {\r\n    assertUninitialized(this);\r\n    if (this[kOptions].tailable) {\r\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\r\n    }\r\n\r\n    if (typeof value !== 'number') {\r\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\r\n    }\r\n\r\n    this[kOptions].batchSize = value;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\r\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\r\n   * if the resultant data has already been retrieved by this cursor.\r\n   */\r\n  rewind(): void {\r\n    if (!this[kInitialized]) {\r\n      return;\r\n    }\r\n\r\n    this[kId] = null;\r\n    this[kDocuments].clear();\r\n    this[kClosed] = false;\r\n    this[kKilled] = false;\r\n    this[kInitialized] = false;\r\n\r\n    const session = this[kSession];\r\n    if (session) {\r\n      // We only want to end this session if we created it, and it hasn't ended yet\r\n      if (session.explicit === false) {\r\n        if (!session.hasEnded) {\r\n          session.endSession().catch(() => null);\r\n        }\r\n        this[kSession] = this.client.startSession({ owner: this, explicit: false });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\r\n   */\r\n  abstract clone(): AbstractCursor<TSchema>;\r\n\r\n  /** @internal */\r\n  protected abstract _initialize(\r\n    session: ClientSession | undefined,\r\n    callback: Callback<ExecutionResult>\r\n  ): void;\r\n\r\n  /** @internal */\r\n  _getMore(batchSize: number, callback: Callback<Document>): void {\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const getMoreOperation = new GetMoreOperation(this[kNamespace], this[kId]!, this[kServer]!, {\r\n      ...this[kOptions],\r\n      session: this[kSession],\r\n      batchSize\r\n    });\r\n\r\n    executeOperation(this[kClient], getMoreOperation, callback);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   *\r\n   * This function is exposed for the unified test runner's createChangeStream\r\n   * operation.  We cannot refactor to use the abstract _initialize method without\r\n   * a significant refactor.\r\n   */\r\n  [kInit](callback: Callback<TSchema | null>): void {\r\n    this._initialize(this[kSession], (error, state) => {\r\n      if (state) {\r\n        const response = state.response;\r\n        this[kServer] = state.server;\r\n\r\n        if (response.cursor) {\r\n          // TODO(NODE-2674): Preserve int64 sent from MongoDB\r\n          this[kId] =\r\n            typeof response.cursor.id === 'number'\r\n              ? Long.fromNumber(response.cursor.id)\r\n              : typeof response.cursor.id === 'bigint'\r\n              ? Long.fromBigInt(response.cursor.id)\r\n              : response.cursor.id;\r\n\r\n          if (response.cursor.ns) {\r\n            this[kNamespace] = ns(response.cursor.ns);\r\n          }\r\n\r\n          this[kDocuments].pushMany(response.cursor.firstBatch);\r\n        }\r\n\r\n        // When server responses return without a cursor document, we close this cursor\r\n        // and return the raw server response. This is often the case for explain commands\r\n        // for example\r\n        if (this[kId] == null) {\r\n          this[kId] = Long.ZERO;\r\n          // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\r\n          this[kDocuments].push(state.response as TODO_NODE_3286);\r\n        }\r\n      }\r\n\r\n      // the cursor is now initialized, even if an error occurred or it is dead\r\n      this[kInitialized] = true;\r\n\r\n      if (error) {\r\n        return cleanupCursor(this, { error }, () => callback(error, undefined));\r\n      }\r\n\r\n      if (cursorIsDead(this)) {\r\n        return cleanupCursor(this, undefined, () => callback());\r\n      }\r\n\r\n      callback();\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @param cursor - the cursor on which to call `next`\r\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\r\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\r\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\r\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\r\n *     not indicate the end of the cursor.\r\n * @param transform - if true, the cursor's transform function is applied to the result document (if the transform exists)\r\n * @returns the next document in the cursor, or `null`.  When `blocking` is `true`, a `null` document means\r\n * the cursor has been exhausted.  Otherwise, it means that there is no document available in the cursor's buffer.\r\n */\r\nasync function next<T>(\r\n  cursor: AbstractCursor<T>,\r\n  {\r\n    blocking,\r\n    transform\r\n  }: {\r\n    blocking: boolean;\r\n    transform: boolean;\r\n  }\r\n): Promise<T | null> {\r\n  const cursorId = cursor[kId];\r\n  if (cursor.closed) {\r\n    return null;\r\n  }\r\n\r\n  if (cursor[kDocuments].length !== 0) {\r\n    const doc = cursor[kDocuments].shift();\r\n\r\n    if (doc != null && transform && cursor[kTransform]) {\r\n      try {\r\n        return cursor[kTransform](doc);\r\n      } catch (error) {\r\n        await cleanupCursorAsync(cursor, { error, needsToEmitClosed: true }).catch(() => {\r\n          // `cleanupCursorAsync` should never throw, but if it does we want to throw the original\r\n          // error instead.\r\n        });\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    return doc;\r\n  }\r\n\r\n  if (cursorId == null) {\r\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\r\n    const init = promisify(cb => cursor[kInit](cb));\r\n    await init();\r\n    return next(cursor, { blocking, transform });\r\n  }\r\n\r\n  if (cursorIsDead(cursor)) {\r\n    // if the cursor is dead, we clean it up\r\n    // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\r\n    // and we should surface the error\r\n    await cleanupCursorAsync(cursor, {});\r\n    return null;\r\n  }\r\n\r\n  // otherwise need to call getMore\r\n  const batchSize = cursor[kOptions].batchSize || 1000;\r\n  const getMore = promisify((batchSize: number, cb: Callback<Document | undefined>) =>\r\n    cursor._getMore(batchSize, cb)\r\n  );\r\n\r\n  let response: Document | undefined;\r\n  try {\r\n    response = await getMore(batchSize);\r\n  } catch (error) {\r\n    if (error) {\r\n      await cleanupCursorAsync(cursor, { error }).catch(() => {\r\n        // `cleanupCursorAsync` should never throw, but if it does we want to throw the original\r\n        // error instead.\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  if (response) {\r\n    const cursorId =\r\n      typeof response.cursor.id === 'number'\r\n        ? Long.fromNumber(response.cursor.id)\r\n        : typeof response.cursor.id === 'bigint'\r\n        ? Long.fromBigInt(response.cursor.id)\r\n        : response.cursor.id;\r\n\r\n    cursor[kDocuments].pushMany(response.cursor.nextBatch);\r\n    cursor[kId] = cursorId;\r\n  }\r\n\r\n  if (cursorIsDead(cursor)) {\r\n    // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\r\n    // we intentionally clean up the cursor to release its session back into the pool before the cursor\r\n    // is iterated.  This prevents a cursor that is exhausted on the server from holding\r\n    // onto a session indefinitely until the AbstractCursor is iterated.\r\n    //\r\n    // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\r\n    // and we should surface the error\r\n    await cleanupCursorAsync(cursor, {});\r\n  }\r\n\r\n  if (cursor[kDocuments].length === 0 && blocking === false) {\r\n    return null;\r\n  }\r\n\r\n  return next(cursor, { blocking, transform });\r\n}\r\n\r\nfunction cursorIsDead(cursor: AbstractCursor): boolean {\r\n  const cursorId = cursor[kId];\r\n  return !!cursorId && cursorId.isZero();\r\n}\r\n\r\nconst cleanupCursorAsync = promisify(cleanupCursor);\r\n\r\nfunction cleanupCursor(\r\n  cursor: AbstractCursor,\r\n  options: { error?: AnyError | undefined; needsToEmitClosed?: boolean } | undefined,\r\n  callback: Callback\r\n): void {\r\n  const cursorId = cursor[kId];\r\n  const cursorNs = cursor[kNamespace];\r\n  const server = cursor[kServer];\r\n  const session = cursor[kSession];\r\n  const error = options?.error;\r\n\r\n  // Cursors only emit closed events once the client-side cursor has been exhausted fully or there\r\n  // was an error.  Notably, when the server returns a cursor id of 0 and a non-empty batch, we\r\n  // cleanup the cursor but don't emit a `close` event.\r\n  const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;\r\n\r\n  if (error) {\r\n    if (cursor.loadBalanced && error instanceof MongoNetworkError) {\r\n      return completeCleanup();\r\n    }\r\n  }\r\n\r\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\r\n    if (needsToEmitClosed) {\r\n      cursor[kClosed] = true;\r\n      cursor[kId] = Long.ZERO;\r\n      cursor.emit(AbstractCursor.CLOSE);\r\n    }\r\n\r\n    if (session) {\r\n      if (session.owner === cursor) {\r\n        session.endSession({ error }).finally(() => {\r\n          callback();\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!session.inTransaction()) {\r\n        maybeClearPinnedConnection(session, { error });\r\n      }\r\n    }\r\n\r\n    return callback();\r\n  }\r\n\r\n  function completeCleanup() {\r\n    if (session) {\r\n      if (session.owner === cursor) {\r\n        session.endSession({ error }).finally(() => {\r\n          cursor.emit(AbstractCursor.CLOSE);\r\n          callback();\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!session.inTransaction()) {\r\n        maybeClearPinnedConnection(session, { error });\r\n      }\r\n    }\r\n\r\n    cursor.emit(AbstractCursor.CLOSE);\r\n    return callback();\r\n  }\r\n\r\n  cursor[kKilled] = true;\r\n\r\n  if (session.hasEnded) {\r\n    return completeCleanup();\r\n  }\r\n\r\n  executeOperation(\r\n    cursor[kClient],\r\n    new KillCursorsOperation(cursorId, cursorNs, server, { session })\r\n  )\r\n    .catch(() => null)\r\n    .finally(completeCleanup);\r\n}\r\n\r\n/** @internal */\r\nexport function assertUninitialized(cursor: AbstractCursor): void {\r\n  if (cursor[kInitialized]) {\r\n    throw new MongoCursorInUseError();\r\n  }\r\n}\r\n\r\nclass ReadableCursorStream extends Readable {\r\n  private _cursor: AbstractCursor;\r\n  private _readInProgress = false;\r\n\r\n  constructor(cursor: AbstractCursor) {\r\n    super({\r\n      objectMode: true,\r\n      autoDestroy: false,\r\n      highWaterMark: 1\r\n    });\r\n    this._cursor = cursor;\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  override _read(size: number): void {\r\n    if (!this._readInProgress) {\r\n      this._readInProgress = true;\r\n      this._readNext();\r\n    }\r\n  }\r\n\r\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\r\n    this._cursor.close().then(\r\n      () => callback(error),\r\n      closeError => callback(closeError)\r\n    );\r\n  }\r\n\r\n  private _readNext() {\r\n    next(this._cursor, { blocking: true, transform: true }).then(\r\n      result => {\r\n        if (result == null) {\r\n          this.push(null);\r\n        } else if (this.destroyed) {\r\n          this._cursor.close().catch(() => null);\r\n        } else {\r\n          if (this.push(result)) {\r\n            return this._readNext();\r\n          }\r\n\r\n          this._readInProgress = false;\r\n        }\r\n      },\r\n      err => {\r\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\r\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\r\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\r\n        //       propagate the error message by removing this special case.\r\n        if (err.message.match(/server is closed/)) {\r\n          this._cursor.close().catch(() => null);\r\n          return this.push(null);\r\n        }\r\n\r\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\r\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\r\n        //       active getMore in-flight. This used to check if the cursor was killed but once\r\n        //       that changed to happen in cleanup legitimate errors would not destroy the\r\n        //       stream. There are change streams test specifically test these cases.\r\n        if (err.message.match(/operation was interrupted/)) {\r\n          return this.push(null);\r\n        }\r\n\r\n        // NOTE: The two above checks on the message of the error will cause a null to be pushed\r\n        //       to the stream, thus closing the stream before the destroy call happens. This means\r\n        //       that either of those error messages on a change stream will not get a proper\r\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\r\n        //       relies on that error event to be emitted to create its new cursor and thus was not\r\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\r\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\r\n        //       See NODE-4475.\r\n        return this.destroy(err);\r\n      }\r\n    );\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}