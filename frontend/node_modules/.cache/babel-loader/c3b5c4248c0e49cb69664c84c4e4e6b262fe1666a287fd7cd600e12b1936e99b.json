{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = void 0;\nconst stream_1 = require(\"stream\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst commands_1 = require(\"./commands\");\nconst compression_1 = require(\"./wire_protocol/compression\");\nconst constants_1 = require(\"./wire_protocol/constants\");\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nconst kBuffer = Symbol('buffer');\n/**\r\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\r\n * support for optional compression\r\n * @internal\r\n */\nclass MessageStream extends stream_1.Duplex {\n  constructor(options = {}) {\n    super(options);\n    /** @internal */\n    this.isMonitoringConnection = false;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new utils_1.BufferPool();\n  }\n  get buffer() {\n    return this[kBuffer];\n  }\n  _write(chunk, _, callback) {\n    this[kBuffer].append(chunk);\n    processIncomingData(this, callback);\n  }\n  _read( /* size */\n  ) {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n  writeCommand(command, operationDescription) {\n    const agreedCompressor = operationDescription.agreedCompressor ?? 'none';\n    if (agreedCompressor === 'none' || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n    const options = {\n      agreedCompressor,\n      zlibCompressionLevel: operationDescription.zlibCompressionLevel ?? 0\n    };\n    // Compress the message body\n    (0, compression_1.compress)(options, messageToBeCompressed).then(compressedMessage => {\n      // Create the msgHeader of OP_COMPRESSED\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n      compressionDetails.writeUInt8(compression_1.Compressor[agreedCompressor], 8); // compressorID\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    }, error => {\n      operationDescription.cb(error);\n    });\n  }\n}\nexports.MessageStream = MessageStream;\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !compression_1.uncompressibleCommands.has(commandName);\n}\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n  const sizeOfMessage = buffer.getInt32();\n  if (sizeOfMessage == null) {\n    return callback();\n  }\n  if (sizeOfMessage < 0) {\n    return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n  }\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n  }\n  if (sizeOfMessage > buffer.length) {\n    return callback();\n  }\n  const message = buffer.read(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  const monitorHasAnotherHello = () => {\n    if (stream.isMonitoringConnection) {\n      // Can we read the next message size?\n      const sizeOfMessage = buffer.getInt32();\n      if (sizeOfMessage != null && sizeOfMessage <= buffer.length) {\n        return true;\n      }\n    }\n    return false;\n  };\n  let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n    const messageBody = message.subarray(MESSAGE_HEADER_SIZE);\n    // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n    if (monitorHasAnotherHello()) {\n      return processIncomingData(stream, callback);\n    }\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n    if (buffer.length >= 4) {\n      return processIncomingData(stream, callback);\n    }\n    return callback();\n  }\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  (0, compression_1.decompress)(compressorID, compressedBuffer).then(messageBody => {\n    if (messageBody.length !== messageHeader.length) {\n      return callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n    }\n    // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n    if (monitorHasAnotherHello()) {\n      return processIncomingData(stream, callback);\n    }\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n    if (buffer.length >= 4) {\n      return processIncomingData(stream, callback);\n    }\n    return callback();\n  }, error => {\n    return callback(error);\n  });\n}","map":{"version":3,"mappings":"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","names":["MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","kDefaultMaxBsonMessageSize","kBuffer","Symbol","MessageStream","stream_1","constructor","options","maxBsonMessageSize","utils_1","buffer","_write","chunk","_","callback","append","processIncomingData","_read","writeCommand","command","operationDescription","agreedCompressor","canCompress","data","toBin","push","Array","isArray","Buffer","concat","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","zlibCompressionLevel","then","compressedMessage","msgHeader","alloc","writeInt32LE","length","requestId","constants_1","compressionDetails","writeUInt8","compression_1","error","cb","exports","commandDoc","commands_1","query","commandName","Object","keys","has","stream","sizeOfMessage","getInt32","error_1","message","read","messageHeader","responseTo","opCode","monitorHasAnotherHello","isMonitoringConnection","ResponseType","messageBody","subarray","emit","fromCompressed","compressorID","compressedBuffer"],"sources":["C:\\Users\\joelg\\Downloads\\MernStack-Tour-Management-main\\MernStack-Tour-Management-main\\tour-management\\node_modules\\mongodb\\src\\cmap\\message_stream.ts"],"sourcesContent":["import { Duplex, type DuplexOptions } from 'stream';\r\n\r\nimport type { BSONSerializeOptions, Document } from '../bson';\r\nimport { MongoDecompressionError, MongoParseError } from '../error';\r\nimport type { ClientSession } from '../sessions';\r\nimport { BufferPool, type Callback } from '../utils';\r\nimport {\r\n  BinMsg,\r\n  type MessageHeader,\r\n  Msg,\r\n  Response,\r\n  type WriteProtocolMessageType\r\n} from './commands';\r\nimport {\r\n  compress,\r\n  Compressor,\r\n  type CompressorName,\r\n  decompress,\r\n  uncompressibleCommands\r\n} from './wire_protocol/compression';\r\nimport { OP_COMPRESSED, OP_MSG } from './wire_protocol/constants';\r\n\r\nconst MESSAGE_HEADER_SIZE = 16;\r\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\r\n\r\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\r\n/** @internal */\r\nconst kBuffer = Symbol('buffer');\r\n\r\n/** @internal */\r\nexport interface MessageStreamOptions extends DuplexOptions {\r\n  maxBsonMessageSize?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface OperationDescription extends BSONSerializeOptions {\r\n  started: number;\r\n  cb: Callback<Document>;\r\n  documentsReturnedIn?: string;\r\n  noResponse: boolean;\r\n  raw: boolean;\r\n  requestId: number;\r\n  session?: ClientSession;\r\n  agreedCompressor?: CompressorName;\r\n  zlibCompressionLevel?: number;\r\n  $clusterTime?: Document;\r\n}\r\n\r\n/**\r\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\r\n * support for optional compression\r\n * @internal\r\n */\r\nexport class MessageStream extends Duplex {\r\n  /** @internal */\r\n  maxBsonMessageSize: number;\r\n  /** @internal */\r\n  [kBuffer]: BufferPool;\r\n  /** @internal */\r\n  isMonitoringConnection = false;\r\n\r\n  constructor(options: MessageStreamOptions = {}) {\r\n    super(options);\r\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\r\n    this[kBuffer] = new BufferPool();\r\n  }\r\n\r\n  get buffer(): BufferPool {\r\n    return this[kBuffer];\r\n  }\r\n\r\n  override _write(chunk: Buffer, _: unknown, callback: Callback<Buffer>): void {\r\n    this[kBuffer].append(chunk);\r\n    processIncomingData(this, callback);\r\n  }\r\n\r\n  override _read(/* size */): void {\r\n    // NOTE: This implementation is empty because we explicitly push data to be read\r\n    //       when `writeMessage` is called.\r\n    return;\r\n  }\r\n\r\n  writeCommand(\r\n    command: WriteProtocolMessageType,\r\n    operationDescription: OperationDescription\r\n  ): void {\r\n    const agreedCompressor = operationDescription.agreedCompressor ?? 'none';\r\n    if (agreedCompressor === 'none' || !canCompress(command)) {\r\n      const data = command.toBin();\r\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\r\n      return;\r\n    }\r\n    // otherwise, compress the message\r\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\r\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\r\n\r\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\r\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\r\n\r\n    const options = {\r\n      agreedCompressor,\r\n      zlibCompressionLevel: operationDescription.zlibCompressionLevel ?? 0\r\n    };\r\n    // Compress the message body\r\n    compress(options, messageToBeCompressed).then(\r\n      compressedMessage => {\r\n        // Create the msgHeader of OP_COMPRESSED\r\n        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\r\n        msgHeader.writeInt32LE(\r\n          MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\r\n          0\r\n        ); // messageLength\r\n        msgHeader.writeInt32LE(command.requestId, 4); // requestID\r\n        msgHeader.writeInt32LE(0, 8); // responseTo (zero)\r\n        msgHeader.writeInt32LE(OP_COMPRESSED, 12); // opCode\r\n\r\n        // Create the compression details of OP_COMPRESSED\r\n        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\r\n        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\r\n        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\r\n        compressionDetails.writeUInt8(Compressor[agreedCompressor], 8); // compressorID\r\n        this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\r\n      },\r\n      error => {\r\n        operationDescription.cb(error);\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n// Return whether a command contains an uncompressible command term\r\n// Will return true if command contains no uncompressible command terms\r\nfunction canCompress(command: WriteProtocolMessageType) {\r\n  const commandDoc = command instanceof Msg ? command.command : command.query;\r\n  const commandName = Object.keys(commandDoc)[0];\r\n  return !uncompressibleCommands.has(commandName);\r\n}\r\n\r\nfunction processIncomingData(stream: MessageStream, callback: Callback<Buffer>): void {\r\n  const buffer = stream[kBuffer];\r\n  const sizeOfMessage = buffer.getInt32();\r\n\r\n  if (sizeOfMessage == null) {\r\n    return callback();\r\n  }\r\n\r\n  if (sizeOfMessage < 0) {\r\n    return callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\r\n  }\r\n\r\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\r\n    return callback(\r\n      new MongoParseError(\r\n        `Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`\r\n      )\r\n    );\r\n  }\r\n\r\n  if (sizeOfMessage > buffer.length) {\r\n    return callback();\r\n  }\r\n\r\n  const message = buffer.read(sizeOfMessage);\r\n  const messageHeader: MessageHeader = {\r\n    length: message.readInt32LE(0),\r\n    requestId: message.readInt32LE(4),\r\n    responseTo: message.readInt32LE(8),\r\n    opCode: message.readInt32LE(12)\r\n  };\r\n\r\n  const monitorHasAnotherHello = () => {\r\n    if (stream.isMonitoringConnection) {\r\n      // Can we read the next message size?\r\n      const sizeOfMessage = buffer.getInt32();\r\n      if (sizeOfMessage != null && sizeOfMessage <= buffer.length) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\r\n  if (messageHeader.opCode !== OP_COMPRESSED) {\r\n    const messageBody = message.subarray(MESSAGE_HEADER_SIZE);\r\n\r\n    // If we are a monitoring connection message stream and\r\n    // there is more in the buffer that can be read, skip processing since we\r\n    // want the last hello command response that is in the buffer.\r\n    if (monitorHasAnotherHello()) {\r\n      return processIncomingData(stream, callback);\r\n    }\r\n\r\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\r\n\r\n    if (buffer.length >= 4) {\r\n      return processIncomingData(stream, callback);\r\n    }\r\n    return callback();\r\n  }\r\n\r\n  messageHeader.fromCompressed = true;\r\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\r\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\r\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\r\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\r\n\r\n  // recalculate based on wrapped opcode\r\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\r\n  decompress(compressorID, compressedBuffer).then(\r\n    messageBody => {\r\n      if (messageBody.length !== messageHeader.length) {\r\n        return callback(\r\n          new MongoDecompressionError('Message body and message header must be the same length')\r\n        );\r\n      }\r\n\r\n      // If we are a monitoring connection message stream and\r\n      // there is more in the buffer that can be read, skip processing since we\r\n      // want the last hello command response that is in the buffer.\r\n      if (monitorHasAnotherHello()) {\r\n        return processIncomingData(stream, callback);\r\n      }\r\n      stream.emit('message', new ResponseType(message, messageHeader, messageBody));\r\n\r\n      if (buffer.length >= 4) {\r\n        return processIncomingData(stream, callback);\r\n      }\r\n      return callback();\r\n    },\r\n    error => {\r\n      return callback(error);\r\n    }\r\n  );\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}